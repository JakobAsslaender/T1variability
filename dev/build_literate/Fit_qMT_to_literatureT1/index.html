<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Global fit · T₁ variability</title><meta name="title" content="Global fit · T₁ variability"/><meta property="og:title" content="Global fit · T₁ variability"/><meta property="twitter:title" content="Global fit · T₁ variability"/><meta name="description" content="Documentation for T₁ variability."/><meta property="og:description" content="Documentation for T₁ variability."/><meta property="twitter:description" content="Documentation for T₁ variability."/><meta property="og:url" content="https://JakobAsslaender.github.io/T1variability/build_literate/Fit_qMT_to_literatureT1/"/><meta property="twitter:url" content="https://JakobAsslaender.github.io/T1variability/build_literate/Fit_qMT_to_literatureT1/"/><link rel="canonical" href="https://JakobAsslaender.github.io/T1variability/build_literate/Fit_qMT_to_literatureT1/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">T₁ variability</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../T1_mapping_methods/">T₁-mapping methods</a></li><li class="is-active"><a class="tocitem" href>Global fit</a><ul class="internal"><li><a class="tocitem" href="#Initialize-plot-and-output-vectors"><span>Initialize plot and output vectors</span></a></li><li><a class="tocitem" href="#Mono-exponential-fit"><span>Mono-exponential fit</span></a></li><li><a class="tocitem" href="#Unconstrained-qMT-fit-with-Graham&#39;s-model"><span>Unconstrained qMT fit with Graham&#39;s model</span></a></li><li><a class="tocitem" href="#Constrained-qMT-fit-with-the-generalized-Bloch-model"><span>Constrained qMT fit with the generalized Bloch model</span></a></li><li><a class="tocitem" href="#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-4"><span>Akaike (AIC) and Bayesian (BIC) information criteria</span></a></li><li><a class="tocitem" href="#Data-analysis"><span>Data analysis</span></a></li></ul></li><li><a class="tocitem" href="../helper_functions/">Helper functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Global fit</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Global fit</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JakobAsslaender/T1variability" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JakobAsslaender/T1variability/blob/master/Fit_qMT_to_literatureT1.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Global-fit"><a class="docs-heading-anchor" href="#Global-fit">Global fit</a><a id="Global-fit-1"></a><a class="docs-heading-anchor-permalink" href="#Global-fit" title="Permalink"></a></h1><p>First, we load the required packages and include some <a href="../helper_functions/#Helper-functions">Helper functions</a></p><pre><code class="language-julia hljs">include(&quot;helper_functions.jl&quot;)</code></pre><p>and load all T₁ mapping methods:</p><pre><code class="language-julia hljs">include(&quot;T1_mapping_methods.jl&quot;)</code></pre><h2 id="Initialize-plot-and-output-vectors"><a class="docs-heading-anchor" href="#Initialize-plot-and-output-vectors">Initialize plot and output vectors</a><a id="Initialize-plot-and-output-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-plot-and-output-vectors" title="Permalink"></a></h2><pre><code class="language-julia hljs">p = plot([0.55, 1.15], [0.55, 1.15], xlabel=&quot;T1 simulated&quot;, ylabel=&quot;T1 measured&quot;, legend=:topleft, label=:none)
marker_list = [(seq_type_i == :IR) ? (:circle) : ((seq_type_i == :LL) ? (:cross) : ((seq_type_i == :vFA) ? (:diamond) : ((seq_type_i == :SR) ? (:dtriangle) : (:x)))) for seq_type_i in seq_type]

fit_name = String[]
fitted_param = NTuple{6, Float64}[]
T1_simulated = Array{Float64}[]
ΔAIC_v = Float64[]
ΔBIC_v = Float64[]</code></pre><h2 id="Mono-exponential-fit"><a class="docs-heading-anchor" href="#Mono-exponential-fit">Mono-exponential fit</a><a id="Mono-exponential-fit-1"></a><a class="docs-heading-anchor-permalink" href="#Mono-exponential-fit" title="Permalink"></a></h2><p>We simulate the mono-exponential model as an MT model with a vanishing semi-solid spin pool. In this case, the underlying MT model is irrelevant and we choose Graham&#39;s model for speed purposes:</p><pre><code class="language-julia hljs">MT_model = Graham()
push!(fit_name, &quot;mono_exp&quot;)</code></pre><p>The following parameters are hard-coded with the exception of <code>R1f</code>, which serves as an initialization for the global fit.</p><pre><code class="language-julia hljs">m0s = 0
R1f = 1 / 1.084  # 1/s
R2f = 1 / 0.0769 # 1/s
Rx = 0           # 1/s
R1s = R1f        # 1/s
T2s = 0
ω0 = 0
B1 = 1</code></pre><p>We define a model for the global fit. It takes the global set of parameters <code>p</code> as an input and returns a vector of T₁ estimates that correspond to the T₁ mapping methods described by the vector <code>T1_functions</code></p><pre><code class="language-julia hljs">function model(iseq, p)
    R1f = p[1]
    T1 = similar(iseq, Float64)
    Threads.@threads for i in eachindex(iseq)
        T1[i] = T1_functions[iseq[i]](m0s, R1f, R2f, Rx, R1s, T2s)
    end
    return T1
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">model (generic function with 1 method)</code></pre><p>Perform the fit and save the global set of parameters:</p><pre><code class="language-julia hljs">fit_mono = curve_fit(model, 1:length(T1_literature), T1_literature, [R1f], x_tol=1e-3)
push!(fitted_param, (m0s, fit_mono.param[1], R2f, Rx, R1s, T2s))
push!(T1_simulated, model(1:length(T1_literature), fit_mono.param))</code></pre><p>For this model, the global set of parameters is:</p><pre><code class="language-julia hljs">m0s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0</code></pre><pre><code class="language-julia hljs">T1f_fitted = 1/fit_mono.param[1] # s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.9995911599982792</code></pre><pre><code class="language-julia hljs">1/R1s # s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.084</code></pre><pre><code class="language-julia hljs">1/R2f # s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0769</code></pre><pre><code class="language-julia hljs">T2s # s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0</code></pre><pre><code class="language-julia hljs">Rx # 1/s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0</code></pre><p>where all but <code>R1f</code> are fixed. The following plot visualizes the quality of the fit an replicates Fig. 1 in the manuscript:</p><pre><code class="language-julia hljs">scatter!(p, T1_simulated[end], T1_literature, label=&quot;$(fit_name[end]) model&quot;, markershape=marker_list, hover=seq_name)</code></pre><object type="text/html" data="../../plots/793555302.html" style="width:100%;height:425px;"></object><h3 id="Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria"><a class="docs-heading-anchor" href="#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria">Akaike (AIC) and Bayesian (BIC) information criteria</a><a id="Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-1"></a><a class="docs-heading-anchor-permalink" href="#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria" title="Permalink"></a></h3><p>The information criteria depend on the number of measurements <code>n</code>, the number of parameters <code>k</code>, and the squared sum of the residuals <code>RSS</code>:</p><pre><code class="language-julia hljs">n = length(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">25</code></pre><pre><code class="language-julia hljs">k = length(fit_mono.param)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><pre><code class="language-julia hljs">RSS = norm(fit_mono.resid)^2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.6649055967245594</code></pre><p>As the AIC and BIC are only informative in the difference, between two models, we use the mono-exponential model as the reference:</p><pre><code class="language-julia hljs">AIC_mono = n * log(RSS / n) + 2k</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-88.6746508271106</code></pre><pre><code class="language-julia hljs">BIC_mono = n * log(RSS / n) + k * log(n)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-87.45577500224239</code></pre><p>In this case, <code>ΔAIC</code> is per definition zero:</p><pre><code class="language-julia hljs">ΔAIC = n * log(RSS / n) + 2k - AIC_mono</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0</code></pre><p>as is <code>ΔBIC</code>:</p><pre><code class="language-julia hljs">ΔBIC = n * log(RSS / n) + k * log(n) - BIC_mono</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0</code></pre><p>Store the results:</p><pre><code class="language-julia hljs">push!(ΔAIC_v, ΔAIC)
push!(ΔBIC_v, ΔBIC)</code></pre><h2 id="Unconstrained-qMT-fit-with-Graham&#39;s-model"><a class="docs-heading-anchor" href="#Unconstrained-qMT-fit-with-Graham&#39;s-model">Unconstrained qMT fit with Graham&#39;s model</a><a id="Unconstrained-qMT-fit-with-Graham&#39;s-model-1"></a><a class="docs-heading-anchor-permalink" href="#Unconstrained-qMT-fit-with-Graham&#39;s-model" title="Permalink"></a></h2><pre><code class="language-julia hljs">MT_model = Graham()
push!(fit_name, &quot;unconstr_Graham&quot;)</code></pre><p>The following parameters are hard-coded with the exception of <code>m0s</code>, <code>R1f</code>, and <code>R1s</code>, which serve as an initialization for the global fit.</p><pre><code class="language-julia hljs">m0s = 0.25
R1f = 1 / 1.84   # 1/s
R1s = 1 / 0.34   # 1/s
Rx = 13.6        # 1/s
R2f = 1 / 0.0769 # 1/s
T2s = 12.5e-6    # s
ω0 = 0
B1 = 1</code></pre><p>We define a model for the global fit. It takes the global set of parameters <code>p</code> as an input and returns a vector of T₁ estimates that correspond to the T₁ mapping methods described by the vector <code>T1_functions</code></p><pre><code class="language-julia hljs">function model(iseq, p)
    m0s, R1f, R1s = p
    T1 = similar(iseq, Float64)
    Threads.@threads for i in eachindex(iseq)
        T1[i] = T1_functions[iseq[i]](m0s, R1f, R2f, Rx, R1s, T2s)
    end
    return T1
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">model (generic function with 1 method)</code></pre><p>Perform the fit and save the global set of parameters:</p><pre><code class="language-julia hljs">fit_Graham = curve_fit(model, 1:length(T1_literature), T1_literature, [m0s, R1f, R1s], x_tol=1e-3)
push!(fitted_param, (fit_Graham.param[1], fit_Graham.param[2], R2f, Rx, fit_Graham.param[3], T2s))
push!(T1_simulated, model(1:length(T1_literature), fit_Graham.param))</code></pre><p>For this model, the global set of parameters is:</p><pre><code class="language-julia hljs">m0s_fitted = fit_Graham.param[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.24998391108282114</code></pre><pre><code class="language-julia hljs">T1f_fitted = 1/fit_Graham.param[2] # s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.8401294832093167</code></pre><pre><code class="language-julia hljs">T1s_fitted = 1/fit_Graham.param[3] # s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.33999359244534394</code></pre><pre><code class="language-julia hljs">1/R2f # s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0769</code></pre><pre><code class="language-julia hljs">T2s # s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.25e-5</code></pre><pre><code class="language-julia hljs">Rx # 1/s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">13.6</code></pre><p>where all but <code>m0s</code>, <code>R1f</code>, and <code>R1s</code> are fixed. The following plot visualizes the quality of the fit an replicates Fig. 1 in the manuscript:</p><pre><code class="language-julia hljs">scatter!(p, T1_simulated[end], T1_literature, label=&quot;$(fit_name[end]) model&quot;, markershape=marker_list, hover=seq_name)</code></pre><object type="text/html" data="../../plots/914664125.html" style="width:100%;height:425px;"></object><h3 id="Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-2"><a class="docs-heading-anchor" href="#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-2">Akaike (AIC) and Bayesian (BIC) information criteria</a><a class="docs-heading-anchor-permalink" href="#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-2" title="Permalink"></a></h3><p>The information criteria depend on the number of measurements <code>n</code>, the number of parameters <code>k</code>, and the squared sum of the residuals <code>RSS</code>:</p><pre><code class="language-julia hljs">n = length(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">25</code></pre><pre><code class="language-julia hljs">k = length(fit_Graham.param)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3</code></pre><pre><code class="language-julia hljs">RSS = norm(fit_Graham.resid)^2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.20754071151461898</code></pre><p>With this information, we can calculate the AIC difference to the mono-exponential model:</p><pre><code class="language-julia hljs">ΔAIC = n * log(RSS / n) + 2k - AIC_mono</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-25.10793875673562</code></pre><p>and similarly for the BIC:</p><pre><code class="language-julia hljs">ΔBIC = n * log(RSS / n) + k * log(n) - BIC_mono</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-22.670187106999222</code></pre><p>Store the results:</p><pre><code class="language-julia hljs">push!(ΔAIC_v, ΔAIC)
push!(ΔBIC_v, ΔBIC)</code></pre><h2 id="Constrained-qMT-fit-with-the-generalized-Bloch-model"><a class="docs-heading-anchor" href="#Constrained-qMT-fit-with-the-generalized-Bloch-model">Constrained qMT fit with the generalized Bloch model</a><a id="Constrained-qMT-fit-with-the-generalized-Bloch-model-1"></a><a class="docs-heading-anchor-permalink" href="#Constrained-qMT-fit-with-the-generalized-Bloch-model" title="Permalink"></a></h2><pre><code class="language-julia hljs">MT_model = gBloch()
push!(fit_name, &quot;constr_gBloch&quot;)</code></pre><p>The following parameters are hard-coded with the exception of <code>m0s</code>, and <code>R1f</code>, which serve as an initialization for the global fit.</p><pre><code class="language-julia hljs">m0s = 0.139
R1f = 1 / 1.084  # 1/s
R2f = 1 / 0.0769 # 1/s
Rx = 23          # 1/s
R1s = 1          # 1/s
T2s = 12.5e-6    # s
ω0 = 0
B1 = 1</code></pre><p>We define a model for the global fit. It takes the global set of parameters <code>p</code> as an input and returns a vector of T₁ estimates that correspond to the T₁ mapping methods described by the vector <code>T1_functions</code></p><pre><code class="language-julia hljs">function model(iseq, p)
    m0s, R1f = p
    R1s = R1f
    T1 = similar(iseq, Float64)
    Threads.@threads for i in eachindex(iseq)
        T1[i] = T1_functions[iseq[i]](m0s, R1f, R2f, Rx, R1s, T2s)
    end
    return T1
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">model (generic function with 1 method)</code></pre><p>Perform the fit and save the global set of parameters:</p><pre><code class="language-julia hljs">fit_constr = curve_fit(model, 1:length(T1_literature), T1_literature, [m0s, R1f], x_tol=1e-3)
push!(fitted_param, (fit_constr.param[1], fit_constr.param[2], R2f, Rx, fit_constr.param[2], T2s))
push!(T1_simulated, model(1:length(T1_literature), fit_constr.param))</code></pre><p>For this model, the global set of parameters is:</p><pre><code class="language-julia hljs">m0s_fitted = fit_constr.param[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.12876420879770573</code></pre><pre><code class="language-julia hljs">T1f_fitted = 1/fit_constr.param[2] # s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.9741872399661978</code></pre><pre><code class="language-julia hljs">T1s_fitted = 1/fit_constr.param[2] # s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.9741872399661978</code></pre><pre><code class="language-julia hljs">1/R2f # s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0769</code></pre><pre><code class="language-julia hljs">T2s # s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.25e-5</code></pre><pre><code class="language-julia hljs">Rx # 1/s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">23</code></pre><p>where all but <code>m0s</code>, <code>R1f</code>, and are fixed (<code>R1s = R1f</code>). The following plot visualizes the quality of the fit an replicates Fig. 1 in the manuscript:</p><pre><code class="language-julia hljs">scatter!(p, T1_simulated[end], T1_literature, label=&quot;$(fit_name[end]) model&quot;, markershape=marker_list, hover=seq_name)</code></pre><object type="text/html" data="../../plots/991765057.html" style="width:100%;height:425px;"></object><h3 id="Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-3"><a class="docs-heading-anchor" href="#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-3">Akaike (AIC) and Bayesian (BIC) information criteria</a><a class="docs-heading-anchor-permalink" href="#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-3" title="Permalink"></a></h3><p>The information criteria depend on the number of measurements <code>n</code>, the number of parameters <code>k</code>, and the squared sum of the residuals <code>RSS</code>:</p><pre><code class="language-julia hljs">n = length(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">25</code></pre><pre><code class="language-julia hljs">k = length(fit_constr.param)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2</code></pre><pre><code class="language-julia hljs">RSS = norm(fit_constr.resid)^2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.17054658156951422</code></pre><p>With this information, we can calculate the AIC difference to the mono-exponential model:</p><pre><code class="language-julia hljs">ΔAIC = n * log(RSS / n) + 2k - AIC_mono</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-32.015915141747996</code></pre><p>and similarly for the BIC:</p><pre><code class="language-julia hljs">ΔBIC = n * log(RSS / n) + k * log(n) - BIC_mono</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-30.797039316879804</code></pre><p>Store the results:</p><pre><code class="language-julia hljs">push!(ΔAIC_v, ΔAIC)
push!(ΔBIC_v, ΔBIC)</code></pre><p>Unconstrained qMT fit with the generalized Bloch model</p><pre><code class="language-julia hljs">MT_model = gBloch()
push!(fit_name, &quot;unconstr_gBloch&quot;)</code></pre><p>The following parameters are hard-coded with the exception of <code>m0s</code>, <code>R1f</code>, and <code>R1s</code>, which serve as an initialization for the global fit.</p><pre><code class="language-julia hljs">m0s = 0.25
R1f = 1 / 1.84   # 1/s
R1s = 1 / 0.34   # 1/s
Rx = 13.6        # 1/s
R2f = 1 / 0.0769 # 1/s
T2s = 12.5e-6    # s
ω0 = 0
B1 = 1</code></pre><p>We define a model for the global fit. It takes the global set of parameters <code>p</code> as an input and returns a vector of T₁ estimates that correspond to the T₁ mapping methods described by the vector <code>T1_functions</code></p><pre><code class="language-julia hljs">function model(iseq, p)
    m0s, R1f, R1s = p
    T1 = similar(iseq, Float64)
    Threads.@threads for i in eachindex(iseq)
        T1[i] = T1_functions[iseq[i]](m0s, R1f, R2f, Rx, R1s, T2s)
    end
    return T1
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">model (generic function with 1 method)</code></pre><p>Perform the fit and save the global set of parameters:</p><pre><code class="language-julia hljs">fit_uncon = curve_fit(model, 1:length(T1_literature), T1_literature, [m0s, R1f, R1s], x_tol=1e-3, show_trace=true)
push!(fitted_param, (fit_uncon.param[1], fit_uncon.param[2], R2f, Rx, fit_uncon.param[3], T2s))
push!(T1_simulated, model(1:length(T1_literature), fit_uncon.param))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">     0     1.529836e-01              NaN
 * lambda: 10.0

     1     1.427944e-01     1.361395e+00
 * g(x): 1.361394780800564
 * lambda: 1.0
 * dx: [-0.0013745831337565319, -0.003522936070709848, -0.016071177870773636]

     2     1.279716e-01     4.522279e-01
 * g(x): 0.45222794600592586
 * lambda: 0.1
 * dx: [-0.004611769090964575, -0.008169042037551536, -0.025371057553171143]

     3     1.216201e-01     7.863024e-02
 * g(x): 0.0786302354472867
 * lambda: 0.010000000000000002
 * dx: [-0.011996010813970063, 0.0019321666583338255, 0.12888997510863884]

     4     1.163489e-01     2.840106e-01
 * g(x): 0.2840105678660218
 * lambda: 0.0010000000000000002
 * dx: [-0.020547807147390088, -0.009304119051695951, 0.3991858008100753]

     5     1.148559e-01     7.454745e-02
 * g(x): 0.07454745341473222
 * lambda: 0.00010000000000000003
 * dx: [-0.002951029758308801, -0.03056336754938424, 0.3163908377472401]

     6     1.147965e-01     7.447726e-04
 * g(x): 0.0007447726071052823
 * lambda: 1.0000000000000004e-5
 * dx: [0.0006424129135830949, -0.010434641798781964, 0.07037001652135765]

     7     1.147963e-01     5.736990e-06
 * g(x): 5.736989536953006e-6
 * lambda: 1.0000000000000004e-6
 * dx: [-0.00011198581333618622, 0.001183491815387707, -0.005319540937281819]

     8     1.147963e-01     1.851575e-07
 * g(x): 1.85157516364061e-7
 * lambda: 1.0000000000000005e-7
 * dx: [-1.2602002159813853e-5, 4.2134695511747696e-5, -2.8857311356288427e-7]</code></pre><p>For this model, the global set of parameters is:</p><pre><code class="language-julia hljs">m0s_fitted = fit_uncon.param[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.2090366251536971</code></pre><pre><code class="language-julia hljs">T1f_fitted = 1/fit_uncon.param[2] # s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2.0633789648113487</code></pre><pre><code class="language-julia hljs">T1s_fitted = 1/fit_uncon.param[3] # s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.2625187971575014</code></pre><pre><code class="language-julia hljs">1/R2f # s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0769</code></pre><pre><code class="language-julia hljs">T2s # s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.25e-5</code></pre><pre><code class="language-julia hljs">Rx # 1/s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">13.6</code></pre><p>where all but <code>m0s</code>, <code>R1f</code>, and <code>R1s</code> are fixed. The following plot visualizes the quality of the fit an replicates Fig. 1 in the manuscript:</p><pre><code class="language-julia hljs">scatter!(p, T1_simulated[end], T1_literature, label=&quot;$(fit_name[end]) model&quot;, markershape=marker_list, hover=seq_name)</code></pre><object type="text/html" data="../../plots/603495954.html" style="width:100%;height:425px;"></object><h2 id="Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-4"><a class="docs-heading-anchor" href="#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-4">Akaike (AIC) and Bayesian (BIC) information criteria</a><a class="docs-heading-anchor-permalink" href="#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-4" title="Permalink"></a></h2><p>The information criteria depend on the number of measurements <code>n</code>, the number of parameters <code>k</code>, and the squared sum of the residuals <code>RSS</code>:</p><pre><code class="language-julia hljs">n = length(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">25</code></pre><pre><code class="language-julia hljs">k = length(fit_uncon.param)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3</code></pre><pre><code class="language-julia hljs">RSS = norm(fit_uncon.resid)^2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.11479629901844186</code></pre><p>With this information, we can calculate the AIC difference to the mono-exponential model:</p><pre><code class="language-julia hljs">ΔAIC = n * log(RSS / n) + 2k - AIC_mono</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-39.91214564788588</code></pre><p>and similarly for the BIC:</p><pre><code class="language-julia hljs">ΔBIC = n * log(RSS / n) + k * log(n) - BIC_mono</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-37.47439399814948</code></pre><p>Store the results:</p><pre><code class="language-julia hljs">push!(ΔAIC_v, ΔAIC)
push!(ΔBIC_v, ΔBIC)</code></pre><h2 id="Data-analysis"><a class="docs-heading-anchor" href="#Data-analysis">Data analysis</a><a id="Data-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Data-analysis" title="Permalink"></a></h2><p>The span of T₁ estimates in the literature is</p><pre><code class="language-julia hljs">extrema(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.64, 1.0855)</code></pre><p>and the coefficient of variation is</p><pre><code class="language-julia hljs">variation(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.1408807728048427</code></pre><h3 id="Median-absolute-deviation"><a class="docs-heading-anchor" href="#Median-absolute-deviation">Median absolute deviation</a><a id="Median-absolute-deviation-1"></a><a class="docs-heading-anchor-permalink" href="#Median-absolute-deviation" title="Permalink"></a></h3><p>In the paper, the median absolute deviation wrt. the mean value is used, as it is more robust to outliers compared to the mean absolute deviation or the standard deviation. Note, however, that the median absolute deviation of the mono-exponential fit is dominated by an outlier, artificially inflating the corresponding reduction.</p><p>A mono-exponential model explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - mad(fit_mono.resid;   center=mean(fit_mono.resid))    / mad(T1_literature; center=mean(T1_literature))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0737575927791515</code></pre><p>Graham&#39;s spectral model without constraints on <code>R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - mad(fit_Graham.resid; center=mean(fit_Graham.resid))  / mad(T1_literature; center=mean(T1_literature))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.5031056930878792</code></pre><p>The generalized Bloch model constrained by <code>R₁ˢ = R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - mad(fit_constr.resid; center=mean(fit_constr.resid))  / mad(T1_literature; center=mean(T1_literature))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.46844427640261666</code></pre><p>The generalized Bloch model without constraints on <code>R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - mad(fit_uncon.resid;  center=mean(fit_uncon.resid))   / mad(T1_literature; center=mean(T1_literature))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.617097175666105</code></pre><h3 id="Mean-absolute-deviation"><a class="docs-heading-anchor" href="#Mean-absolute-deviation">Mean absolute deviation</a><a id="Mean-absolute-deviation-1"></a><a class="docs-heading-anchor-permalink" href="#Mean-absolute-deviation" title="Permalink"></a></h3><p>For comparison, the mean absolute deviation is analyzed: A mono-exponential model explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - mean(abs.(fit_mono.resid   .- mean(fit_mono.resid)))   / mean(abs.(T1_literature .- mean(T1_literature)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.027492595857971924</code></pre><p>Graham&#39;s spectral model without constraints on <code>R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - mean(abs.(fit_Graham.resid .- mean(fit_Graham.resid))) / mean(abs.(T1_literature .- mean(T1_literature)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.448944890037688</code></pre><p>The generalized Bloch model constrained by <code>R₁ˢ = R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - mean(abs.(fit_constr.resid .- mean(fit_constr.resid))) / mean(abs.(T1_literature .- mean(T1_literature)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.42789347942745004</code></pre><p>The generalized Bloch model without constraints on <code>R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - mean(abs.(fit_uncon.resid  .- mean(fit_uncon.resid)))  / mean(abs.(T1_literature .- mean(T1_literature)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.5261514791615332</code></pre><h3 id="Standard-deviation"><a class="docs-heading-anchor" href="#Standard-deviation">Standard deviation</a><a id="Standard-deviation-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-deviation" title="Permalink"></a></h3><p>For comparison, the standard deviation is analyzed: A mono-exponential model explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - std(fit_mono.resid)   / std(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.019849036512416873</code></pre><p>Graham&#39;s spectral model without constraints on <code>R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - std(fit_Graham.resid) / std(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.34031243802512</code></pre><p>The generalized Bloch model constrained by <code>R₁ˢ = R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - std(fit_constr.resid) / std(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.32587060010273305</code></pre><p>The generalized Bloch model without constraints on <code>R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - std(fit_uncon.resid)  / std(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.44688494858876526</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../T1_mapping_methods/">« T₁-mapping methods</a><a class="docs-footer-nextpage" href="../helper_functions/">Helper functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Sunday 8 September 2024 20:56">Sunday 8 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
