<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Global fit · T1variability</title><meta name="title" content="Global fit · T1variability"/><meta property="og:title" content="Global fit · T1variability"/><meta property="twitter:title" content="Global fit · T1variability"/><meta name="description" content="Documentation for T1variability."/><meta property="og:description" content="Documentation for T1variability."/><meta property="twitter:description" content="Documentation for T1variability."/><meta property="og:url" content="https://JakobAsslaender.github.io/T1variability/build_literate/Fit_qMT_to_literatureT1/"/><meta property="twitter:url" content="https://JakobAsslaender.github.io/T1variability/build_literate/Fit_qMT_to_literatureT1/"/><link rel="canonical" href="https://JakobAsslaender.github.io/T1variability/build_literate/Fit_qMT_to_literatureT1/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">T1variability</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../T1_mapping_methods/">T₁ mapping methods</a></li><li class="is-active"><a class="tocitem" href>Global fit</a><ul class="internal"><li><a class="tocitem" href="#Initialize-plot-and-output-vectors"><span>Initialize plot and output vectors</span></a></li><li><a class="tocitem" href="#Mono-exponential-fit"><span>Mono-exponential fit</span></a></li><li><a class="tocitem" href="#Unconstrained-qMT-fit-with-Graham&#39;s-model"><span>Unconstrained qMT fit with Graham&#39;s model</span></a></li><li><a class="tocitem" href="#Constrained-qMT-fit-with-the-generalized-Bloch-model"><span>Constrained qMT fit with the generalized Bloch model</span></a></li><li><a class="tocitem" href="#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-4"><span>Akaike (AIC) and Bayesian (BIC) information criteria</span></a></li><li><a class="tocitem" href="#Data-analysis"><span>Data analysis</span></a></li></ul></li><li><a class="tocitem" href="../helper_functions/">Helper functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Global fit</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Global fit</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JakobAsslaender/T1variability" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JakobAsslaender/T1variability/blob/master/Fit_qMT_to_literatureT1.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Global-fit"><a class="docs-heading-anchor" href="#Global-fit">Global fit</a><a id="Global-fit-1"></a><a class="docs-heading-anchor-permalink" href="#Global-fit" title="Permalink"></a></h1><p>First, we load the required packages and include some <a href="../helper_functions/#Helper-functions">Helper functions</a></p><pre><code class="language-julia hljs">include(&quot;helper_functions.jl&quot;)
nothing #hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>and load all T₁ mapping methods:</p><pre><code class="language-julia hljs">include(&quot;T1_mapping_methods.jl&quot;)
nothing #hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><h2 id="Initialize-plot-and-output-vectors"><a class="docs-heading-anchor" href="#Initialize-plot-and-output-vectors">Initialize plot and output vectors</a><a id="Initialize-plot-and-output-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-plot-and-output-vectors" title="Permalink"></a></h2><pre><code class="language-julia hljs">p = plot([0.55, 1.15], [0.55, 1.15], xlabel=&quot;T1 simulated&quot;, ylabel=&quot;T1 measured&quot;, legend=:topleft, label=:none)
marker_list = [(seq_type_i == :IR) ? (:circle) : ((seq_type_i == :LL) ? (:cross) : ((seq_type_i == :vFA) ? (:diamond) : ((seq_type_i == :SR) ? (:dtriangle) : (:x)))) for seq_type_i in seq_type]

fit_name = String[]
fitted_param = NTuple{6, Float64}[]
T1_simulated = Array{Float64}[]
ΔAIC_v = Float64[]
ΔBIC_v = Float64[]
nothing #hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><h2 id="Mono-exponential-fit"><a class="docs-heading-anchor" href="#Mono-exponential-fit">Mono-exponential fit</a><a id="Mono-exponential-fit-1"></a><a class="docs-heading-anchor-permalink" href="#Mono-exponential-fit" title="Permalink"></a></h2><p>We simulate the mono-exponential model as an MT model with a vanishing semi-solid spin pool. In this case, the underlying MT model is irrelevant and we choose Graham&#39;s model for speed purposes:</p><pre><code class="language-julia hljs">MT_model = Graham()
push!(fit_name, &quot;mono_exp&quot;)
nothing #hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>The following parameters are hard-coded with the exception of <code>R1f</code>, which serves as an initialization for the global fit.</p><pre><code class="language-julia hljs">m0s = 0
R1f = 1 / 1.084  # 1/s
R2f = 1 / 0.0769 # 1/s
Rx = 0           # 1/s
R1s = R1f        # 1/s
T2s = 0
ω0 = 0
B1 = 1
nothing #hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>We define a model for the global fit. It takes the global set of parameters <code>p</code> as an input and returns a vector of T₁ estimates that correspond to the T₁ mapping methods described by the vector <code>T1_functions</code></p><pre><code class="language-julia hljs">function model(iseq, p)
    R1f = p[1]
    T1 = similar(iseq, Float64)
    Threads.@threads for i in eachindex(iseq)
        T1[i] = T1_functions[iseq[i]](m0s, R1f, R2f, Rx, R1s, T2s)
    end
    return T1
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>Perform the fit and save the global set of parameters:</p><pre><code class="language-julia hljs">fit_mono = curve_fit(model, 1:length(T1_literature), T1_literature, [R1f], x_tol=1e-3)
push!(fitted_param, (m0s, fit_mono.param[1], R2f, Rx, R1s, T2s))
push!(T1_simulated, model(1:length(T1_literature), fit_mono.param))
nothing #hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>For this model, the global set of parameters is:</p><pre><code class="language-julia hljs">m0s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">R1f_fitted = fit_mono.param[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">R2f</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">Rx</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">R1s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">T2s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>where all but <code>R1f</code> are fixed. The following plot visualizes the quality of the fit an replicates Fig. 1 in the manuscript:</p><pre><code class="language-julia hljs">scatter!(p, T1_simulated[end], T1_literature, label=&quot;$(fit_name[end]) model&quot;, markershape=marker_list, hover=seq_name)
Main.HTMLPlot(p) #hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><h3 id="Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria"><a class="docs-heading-anchor" href="#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria">Akaike (AIC) and Bayesian (BIC) information criteria</a><a id="Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-1"></a><a class="docs-heading-anchor-permalink" href="#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria" title="Permalink"></a></h3><p>The information criteria depend on the number of measurements <code>n</code>, the number of parameters <code>k</code>, and the squared sum of the residuals <code>RSS</code>:</p><pre><code class="language-julia hljs">n = length(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">k = length(fit_mono.param)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">RSS = norm(fit_mono.resid)^2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>As the AIC and BIC are only informative in the difference, between two models, we use the mono-exponential model as the reference:</p><pre><code class="language-julia hljs">AIC_mono = n * log(RSS / n) + 2k</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">BIC_mono = n * log(RSS / n) + k * log(n)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>In this case, <code>ΔAIC</code> is per definition zero:</p><pre><code class="language-julia hljs">ΔAIC = n * log(RSS / n) + 2k - AIC_mono</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>as is <code>ΔBIC</code>:</p><pre><code class="language-julia hljs">ΔBIC = n * log(RSS / n) + k * log(n) - BIC_mono</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>Store the results:</p><pre><code class="language-julia hljs">push!(ΔAIC_v, ΔAIC)
push!(ΔBIC_v, ΔBIC)
nothing #hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><h2 id="Unconstrained-qMT-fit-with-Graham&#39;s-model"><a class="docs-heading-anchor" href="#Unconstrained-qMT-fit-with-Graham&#39;s-model">Unconstrained qMT fit with Graham&#39;s model</a><a id="Unconstrained-qMT-fit-with-Graham&#39;s-model-1"></a><a class="docs-heading-anchor-permalink" href="#Unconstrained-qMT-fit-with-Graham&#39;s-model" title="Permalink"></a></h2><pre><code class="language-julia hljs">MT_model = Graham()
push!(fit_name, &quot;unconstr_Graham&quot;)
nothing #hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>The following parameters are hard-coded with the exception of <code>m0s</code>, <code>R1f</code>, and <code>R1s</code>, which serve as an initialization for the global fit.</p><pre><code class="language-julia hljs">m0s = 0.25
R1f = 1 / 1.84   # 1/s
R1s = 1 / 0.34   # 1/s
Rx = 13.6        # 1/s
R2f = 1 / 0.0769 # 1/s
T2s = 12.5e-6    # s
ω0 = 0
B1 = 1
nothing #hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>We define a model for the global fit. It takes the global set of parameters <code>p</code> as an input and returns a vector of T₁ estimates that correspond to the T₁ mapping methods described by the vector <code>T1_functions</code></p><pre><code class="language-julia hljs">function model(iseq, p)
    m0s, R1f, R1s = p
    T1 = similar(iseq, Float64)
    Threads.@threads for i in eachindex(iseq)
        T1[i] = T1_functions[iseq[i]](m0s, R1f, R2f, Rx, R1s, T2s)
    end
    return T1
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>Perform the fit and save the global set of parameters:</p><pre><code class="language-julia hljs">fit_Graham = curve_fit(model, 1:length(T1_literature), T1_literature, [m0s, R1f, R1s], x_tol=1e-3)
push!(fitted_param, (fit_Graham.param[1], fit_Graham.param[2], R2f, Rx, fit_Graham.param[3], T2s))
push!(T1_simulated, model(1:length(T1_literature), fit_Graham.param))
nothing #hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>For this model, the global set of parameters is:</p><pre><code class="language-julia hljs">m0s_fitted = fit_Graham.param[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">R1f_fitted = fit_Graham.param[2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">R2f</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">Rx</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">R1s_fitted = fit_Graham.param[3]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">T2s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>where all but <code>m0s</code>, <code>R1f</code>, and <code>R1s</code> are fixed. The following plot visualizes the quality of the fit an replicates Fig. 1 in the manuscript:</p><pre><code class="language-julia hljs">scatter!(p, T1_simulated[end], T1_literature, label=&quot;$(fit_name[end]) model&quot;, markershape=marker_list, hover=seq_name)
Main.HTMLPlot(p) #hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><h3 id="Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-2"><a class="docs-heading-anchor" href="#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-2">Akaike (AIC) and Bayesian (BIC) information criteria</a><a class="docs-heading-anchor-permalink" href="#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-2" title="Permalink"></a></h3><p>The information criteria depend on the number of measurements <code>n</code>, the number of parameters <code>k</code>, and the squared sum of the residuals <code>RSS</code>:</p><pre><code class="language-julia hljs">n = length(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">k = length(fit_mono.param)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">RSS = norm(fit_mono.resid)^2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>With this information, we can calculate the AIC difference to the mono-exponential model:</p><pre><code class="language-julia hljs">ΔAIC = n * log(RSS / n) + 2k - AIC_mono</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>and similarly for the BIC:</p><pre><code class="language-julia hljs">ΔBIC = n * log(RSS / n) + k * log(n) - BIC_mono</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>Store the results:</p><pre><code class="language-julia hljs">push!(ΔAIC_v, ΔAIC)
push!(ΔBIC_v, ΔBIC)
nothing #hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><h2 id="Constrained-qMT-fit-with-the-generalized-Bloch-model"><a class="docs-heading-anchor" href="#Constrained-qMT-fit-with-the-generalized-Bloch-model">Constrained qMT fit with the generalized Bloch model</a><a id="Constrained-qMT-fit-with-the-generalized-Bloch-model-1"></a><a class="docs-heading-anchor-permalink" href="#Constrained-qMT-fit-with-the-generalized-Bloch-model" title="Permalink"></a></h2><pre><code class="language-julia hljs">MT_model = gBloch()
push!(fit_name, &quot;constr_gBloch&quot;)
nothing #hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>The following parameters are hard-coded with the exception of <code>m0s</code>, and <code>R1f</code>, which serve as an initialization for the global fit.</p><pre><code class="language-julia hljs">m0s = 0.139
R1f = 1 / 1.084  # 1/s
R2f = 1 / 0.0769 # 1/s
Rx = 23          # 1/s
R1s = 1          # 1/s
T2s = 12.5e-6    # s
ω0 = 0
B1 = 1
nothing #hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>We define a model for the global fit. It takes the global set of parameters <code>p</code> as an input and returns a vector of T₁ estimates that correspond to the T₁ mapping methods described by the vector <code>T1_functions</code></p><pre><code class="language-julia hljs">function model(iseq, p)
    m0s, R1f = p
    R1s = R1f
    T1 = similar(iseq, Float64)
    Threads.@threads for i in eachindex(iseq)
        T1[i] = T1_functions[iseq[i]](m0s, R1f, R2f, Rx, R1s, T2s)
    end
    return T1
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>Perform the fit and save the global set of parameters:</p><pre><code class="language-julia hljs">fit_constr = curve_fit(model, 1:length(T1_literature), T1_literature, [m0s, R1f], x_tol=1e-3)
push!(fitted_param, (fit_constr.param[1], fit_constr.param[2], R2f, Rx, fit_constr.param[2], T2s))
push!(T1_simulated, model(1:length(T1_literature), fit_constr.param))
nothing #hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>For this model, the global set of parameters is:</p><pre><code class="language-julia hljs">m0s_fitted = fit_constr.param[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">R1f_fitted = fit_constr.param[2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">R2f</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">Rx</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">R1s_fitted = fit_constr.param[2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">T2s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>where all but <code>m0s</code>, <code>R1f</code>, and are fixed (<code>R1s = R1f</code>). The following plot visualizes the quality of the fit an replicates Fig. 1 in the manuscript:</p><pre><code class="language-julia hljs">scatter!(p, T1_simulated[end], T1_literature, label=&quot;$(fit_name[end]) model&quot;, markershape=marker_list, hover=seq_name)
Main.HTMLPlot(p) #hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><h3 id="Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-3"><a class="docs-heading-anchor" href="#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-3">Akaike (AIC) and Bayesian (BIC) information criteria</a><a class="docs-heading-anchor-permalink" href="#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-3" title="Permalink"></a></h3><p>The information criteria depend on the number of measurements <code>n</code>, the number of parameters <code>k</code>, and the squared sum of the residuals <code>RSS</code>:</p><pre><code class="language-julia hljs">n = length(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">k = length(fit_mono.param)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">RSS = norm(fit_mono.resid)^2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>With this information, we can calculate the AIC difference to the mono-exponential model:</p><pre><code class="language-julia hljs">ΔAIC = n * log(RSS / n) + 2k - AIC_mono</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>and similarly for the BIC:</p><pre><code class="language-julia hljs">ΔBIC = n * log(RSS / n) + k * log(n) - BIC_mono</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>Store the results:</p><pre><code class="language-julia hljs">push!(ΔAIC_v, ΔAIC)
push!(ΔBIC_v, ΔBIC)
nothing #hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>Unconstrained qMT fit with the generalized Bloch model</p><pre><code class="language-julia hljs">MT_model = gBloch()
push!(fit_name, &quot;unconstr_gBloch&quot;)
nothing #hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>The following parameters are hard-coded with the exception of <code>m0s</code>, <code>R1f</code>, and <code>R1s</code>, which serve as an initialization for the global fit.</p><pre><code class="language-julia hljs">m0s = 0.25
R1f = 1 / 1.84   # 1/s
R1s = 1 / 0.34   # 1/s
Rx = 13.6        # 1/s
R2f = 1 / 0.0769 # 1/s
T2s = 12.5e-6    # s
ω0 = 0
B1 = 1
nothing #hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>We define a model for the global fit. It takes the global set of parameters <code>p</code> as an input and returns a vector of T₁ estimates that correspond to the T₁ mapping methods described by the vector <code>T1_functions</code></p><pre><code class="language-julia hljs">function model(iseq, p)
    m0s, R1f, R1s = p
    T1 = similar(iseq, Float64)
    Threads.@threads for i in eachindex(iseq)
        T1[i] = T1_functions[iseq[i]](m0s, R1f, R2f, Rx, R1s, T2s)
    end
    return T1
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>Perform the fit and save the global set of parameters:</p><pre><code class="language-julia hljs">fit_uncon = curve_fit(model, 1:length(T1_literature), T1_literature, [m0s, R1f, R1s], x_tol=1e-3, show_trace=true)
push!(fitted_param, (fit_uncon.param[1], fit_uncon.param[2], R2f, Rx, fit_uncon.param[3], T2s))
push!(T1_simulated, model(1:length(T1_literature), fit_uncon.param))
nothing #hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>For this model, the global set of parameters is:</p><pre><code class="language-julia hljs">m0s_fitted = fit_uncon.param[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">R1f_fitted = fit_uncon.param[2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">R2f</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">Rx</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">R1s_fitted = fit_uncon.param[3]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">T2s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>where all but <code>m0s</code>, <code>R1f</code>, and <code>R1s</code> are fixed. The following plot visualizes the quality of the fit an replicates Fig. 1 in the manuscript:</p><pre><code class="language-julia hljs">scatter!(p, T1_simulated[end], T1_literature, label=&quot;$(fit_name[end]) model&quot;, markershape=marker_list, hover=seq_name)
Main.HTMLPlot(p) #hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><h2 id="Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-4"><a class="docs-heading-anchor" href="#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-4">Akaike (AIC) and Bayesian (BIC) information criteria</a><a class="docs-heading-anchor-permalink" href="#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-4" title="Permalink"></a></h2><p>The information criteria depend on the number of measurements <code>n</code>, the number of parameters <code>k</code>, and the squared sum of the residuals <code>RSS</code>:</p><pre><code class="language-julia hljs">n = length(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">k = length(fit_mono.param)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><pre><code class="language-julia hljs">RSS = norm(fit_mono.resid)^2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>With this information, we can calculate the AIC difference to the mono-exponential model:</p><pre><code class="language-julia hljs">ΔAIC = n * log(RSS / n) + 2k - AIC_mono</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>and similarly for the BIC:</p><pre><code class="language-julia hljs">ΔBIC = n * log(RSS / n) + k * log(n) - BIC_mono</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>Store the results:</p><pre><code class="language-julia hljs">push!(ΔAIC_v, ΔAIC)
push!(ΔBIC_v, ΔBIC)
nothing #hide</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><h2 id="Data-analysis"><a class="docs-heading-anchor" href="#Data-analysis">Data analysis</a><a id="Data-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Data-analysis" title="Permalink"></a></h2><p>The span of T₁ estimates in the literature is</p><pre><code class="language-julia hljs">extrema(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>and the coefficient of variation is</p><pre><code class="language-julia hljs">variation(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><h3 id="Median-absolute-deviation"><a class="docs-heading-anchor" href="#Median-absolute-deviation">Median absolute deviation</a><a id="Median-absolute-deviation-1"></a><a class="docs-heading-anchor-permalink" href="#Median-absolute-deviation" title="Permalink"></a></h3><p>In the paper, the median absolute deviation wrt. the mean value is used, as it is more robust to outliers compared to the mean absolute deviation or the standard deviation. Note, however, that the median absolute deviation of the mono-exponential fit is dominated by an outlier, artificially inflating the corresponding reduction.</p><p>A mono-exponential model explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - mad(fit_mono.resid;   center=mean(fit_mono.resid))    / mad(T1_literature; center=mean(T1_literature))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>Graham&#39;s spectral model without constraints on <code>R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - mad(fit_Graham.resid; center=mean(fit_Graham.resid))  / mad(T1_literature; center=mean(T1_literature))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>The generalized Bloch model constrained by <code>R₁ˢ = R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - mad(fit_constr.resid; center=mean(fit_constr.resid))  / mad(T1_literature; center=mean(T1_literature))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>The generalized Bloch model without constraints on <code>R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - mad(fit_uncon.resid;  center=mean(fit_uncon.resid))   / mad(T1_literature; center=mean(T1_literature))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><h3 id="Mean-absolute-deviation"><a class="docs-heading-anchor" href="#Mean-absolute-deviation">Mean absolute deviation</a><a id="Mean-absolute-deviation-1"></a><a class="docs-heading-anchor-permalink" href="#Mean-absolute-deviation" title="Permalink"></a></h3><p>For comparison, the mean absolute deviation is analyzed: A mono-exponential model explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - mean(abs.(fit_mono.resid   .- mean(fit_mono.resid)))   / mean(abs.(T1_literature .- mean(T1_literature)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>Graham&#39;s spectral model without constraints on <code>R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - mean(abs.(fit_Graham.resid .- mean(fit_Graham.resid))) / mean(abs.(T1_literature .- mean(T1_literature)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>The generalized Bloch model constrained by <code>R₁ˢ = R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - mean(abs.(fit_constr.resid .- mean(fit_constr.resid))) / mean(abs.(T1_literature .- mean(T1_literature)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>The generalized Bloch model without constraints on <code>R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - mean(abs.(fit_uncon.resid  .- mean(fit_uncon.resid)))  / mean(abs.(T1_literature .- mean(T1_literature)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><h3 id="Standard-deviation"><a class="docs-heading-anchor" href="#Standard-deviation">Standard deviation</a><a id="Standard-deviation-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-deviation" title="Permalink"></a></h3><p>For comparison, the standard deviation is analyzed: A mono-exponential model explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - std(fit_mono.resid)   / std(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>Graham&#39;s spectral model without constraints on <code>R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - std(fit_Graham.resid) / std(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>The generalized Bloch model constrained by <code>R₁ˢ = R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - std(fit_constr.resid) / std(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre><p>The generalized Bloch model without constraints on <code>R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - std(fit_uncon.resid)  / std(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt;&lt; @example-block not executed in draft mode &gt;&gt;</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../T1_mapping_methods/">« T₁ mapping methods</a><a class="docs-footer-nextpage" href="../helper_functions/">Helper functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Sunday 8 September 2024 00:45">Sunday 8 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
