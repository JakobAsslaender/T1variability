<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Global fit · T₁ variability</title><meta name="title" content="Global fit · T₁ variability"/><meta property="og:title" content="Global fit · T₁ variability"/><meta property="twitter:title" content="Global fit · T₁ variability"/><meta name="description" content="Documentation for T₁ variability."/><meta property="og:description" content="Documentation for T₁ variability."/><meta property="twitter:description" content="Documentation for T₁ variability."/><meta property="og:url" content="https://JakobAsslaender.github.io/T1variability/build_literate/Fit_qMT_to_literatureT1/"/><meta property="twitter:url" content="https://JakobAsslaender.github.io/T1variability/build_literate/Fit_qMT_to_literatureT1/"/><link rel="canonical" href="https://JakobAsslaender.github.io/T1variability/build_literate/Fit_qMT_to_literatureT1/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">T₁ variability</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">T₁ variability</span><ul><li><a class="tocitem" href="../T1_mapping_methods/">T₁-mapping methods</a></li><li class="is-active"><a class="tocitem" href>Global fit</a><ul class="internal"><li><a class="tocitem" href="#Mono-exponential-model"><span>Mono-exponential model</span></a></li><li><a class="tocitem" href="#Graham&#39;s-MT-model-(unconstrained-Rˢ)"><span>Graham&#39;s MT model (unconstrained R₁ˢ)</span></a></li><li><a class="tocitem" href="#Sled&#39;s-MT-model-(unconstrained-Rˢ)"><span>Sled&#39;s MT model (unconstrained R₁ˢ)</span></a></li><li><a class="tocitem" href="#Generalized-Bloch-model-(Rˢ-Rᶠ)"><span>Generalized Bloch model (R₁ˢ = R₁ᶠ)</span></a></li><li><a class="tocitem" href="#Generalized-Bloch-model-(unconstrained-Rˢ)"><span>Generalized Bloch model (unconstrained R₁ˢ)</span></a></li><li><a class="tocitem" href="#Data-analysis"><span>Data analysis</span></a></li></ul></li><li><a class="tocitem" href="../helper_functions/">Helper functions</a></li></ul></li><li><span class="tocitem">T₁ sensitivity</span><ul><li><a class="tocitem" href="../Derivaties/">Sensitivity analysis</a></li><li><a class="tocitem" href="../Derivatives_HelperFunctions/">Helper functions for the sensitivity analysis</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">T₁ variability</a></li><li class="is-active"><a href>Global fit</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Global fit</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JakobAsslaender/T1variability" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JakobAsslaender/T1variability/blob/master/Fit_qMT_to_literatureT1.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Global-fit"><a class="docs-heading-anchor" href="#Global-fit">Global fit</a><a id="Global-fit-1"></a><a class="docs-heading-anchor-permalink" href="#Global-fit" title="Permalink"></a></h1><p>First, we load the required packages and include some <a href="../helper_functions/#Helper-functions">Helper functions</a></p><pre><code class="language-julia hljs">include(&quot;helper_functions.jl&quot;)</code></pre><p>load all <a href="../T1_mapping_methods/#T-mapping-methods">T₁-mapping methods</a>:</p><pre><code class="language-julia hljs">include(&quot;T1_mapping_methods.jl&quot;)</code></pre><p>and initialize the plot:</p><pre><code class="language-julia hljs">p = plot([0, 2], [0, 2], xlabel=&quot;simulated T1 (s)&quot;, ylabel=&quot;literature T1 (s)&quot;, legend=:topleft, label=:none, xlim=(0.5, 1.1), ylim=(0.5, 1.1))
marker_list = [(seq_type_i == :IR) ? (:circle) : ((seq_type_i == :LL) ? (:cross) : ((seq_type_i == :vFA) ? (:diamond) : ((seq_type_i == :SR) ? (:dtriangle) : (:x)))) for seq_type_i in seq_type]</code></pre><h2 id="Mono-exponential-model"><a class="docs-heading-anchor" href="#Mono-exponential-model">Mono-exponential model</a><a id="Mono-exponential-model-1"></a><a class="docs-heading-anchor-permalink" href="#Mono-exponential-model" title="Permalink"></a></h2><p>We simulate the mono-exponential model as an MT model with a vanishing semi-solid spin pool. In this case, the underlying MT model is irrelevant, and we choose Graham&#39;s model for speed purposes:</p><pre><code class="language-julia hljs">MT_model = Graham()</code></pre><p>The following parameters are hard-coded, except for <code>R1f</code>, which serves as an initialization for the global fit.</p><pre><code class="language-julia hljs">m0s = 0
R1f = 1 / 1.084  # 1/s
R1s = R1f        # 1/s
R2f = 1 / 0.0769 # 1/s
T2s = 0
Rx = 0           # 1/s
ω0 = 0
B1 = 1</code></pre><p>We define a model for the global fit. It takes the global set of parameters <code>p</code> as an input and returns a vector of T₁ estimates that correspond to the T₁ mapping methods described by the vector <code>T1_functions</code></p><pre><code class="language-julia hljs">function model(iseq, p)
    R1f = p[1]
    T1 = similar(iseq, Float64)
    Threads.@threads for i in eachindex(iseq)
        T1[i] = T1_functions[iseq[i]](m0s, R1f, R2f, Rx, R1s, T2s)
    end
    return T1
end</code></pre><p>Perform the fit and calculate the simulated T₁:</p><pre><code class="language-julia hljs">fit_mono = curve_fit(model, 1:length(T1_literature), T1_literature, [R1f], x_tol=1e-3)
T1_simulated = model(1:length(T1_literature), fit_mono.param)</code></pre><p>For this model, the single fitted global parameter is:</p><pre><code class="language-julia hljs">T1f = 1 / fit_mono.param[1] # s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.8894530882606787</code></pre><p>The following plot visualizes the quality of the fit and replicates Fig. 1 in the manuscript:</p><pre><code class="language-julia hljs">scatter!(p, T1_simulated, T1_literature, label=&quot;mono-exponential model&quot;, markershape=marker_list, hover=seq_name)</code></pre><object type="text/html" data="../../plots/832950532.html" style="width:620px;height:620px;"></object><h3 id="Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria"><a class="docs-heading-anchor" href="#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria">Akaike (AIC) and Bayesian (BIC) information criteria</a><a id="Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-1"></a><a class="docs-heading-anchor-permalink" href="#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria" title="Permalink"></a></h3><p>The information criteria depend on the number of measurements:</p><pre><code class="language-julia hljs">n = length(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">25</code></pre><p>the number of parameters:</p><pre><code class="language-julia hljs">k = length(fit_mono.param)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><p>and the squared sum of the residuals:</p><pre><code class="language-julia hljs">RSS = norm(fit_mono.resid)^2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.36165228007243183</code></pre><p>As the AIC and BIC are only informative in the difference between two models, we use the mono-exponential model as the reference:</p><pre><code class="language-julia hljs">AIC_mono = n * log(RSS / n) + 2k</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-103.8986976484162</code></pre><pre><code class="language-julia hljs">BIC_mono = n * log(RSS / n) + k * log(n)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-102.679821823548</code></pre><p>In this case, <code>ΔAIC</code> is by definition zero:</p><pre><code class="language-julia hljs">ΔAIC = n * log(RSS / n) + 2k - AIC_mono</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0</code></pre><p>as is <code>ΔBIC</code>:</p><pre><code class="language-julia hljs">ΔBIC = n * log(RSS / n) + k * log(n) - BIC_mono</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0</code></pre><h2 id="Graham&#39;s-MT-model-(unconstrained-Rˢ)"><a class="docs-heading-anchor" href="#Graham&#39;s-MT-model-(unconstrained-Rˢ)">Graham&#39;s MT model (unconstrained R₁ˢ)</a><a id="Graham&#39;s-MT-model-(unconstrained-Rˢ)-1"></a><a class="docs-heading-anchor-permalink" href="#Graham&#39;s-MT-model-(unconstrained-Rˢ)" title="Permalink"></a></h2><pre><code class="language-julia hljs">MT_model = Graham()</code></pre><p>The following parameters are hard-coded, except for <code>m0s</code>, <code>R1f</code>, and <code>R1s</code>, which serve as an initialization for the global fit.</p><pre><code class="language-julia hljs">m0s = 0.25
R1f = 1 / 1.84   # 1/s
R1s = 1 / 0.34   # 1/s
R2f = 1 / 0.0769 # 1/s
T2s = 12.5e-6    # s
Rx = 13.6        # 1/s
ω0 = 0
B1 = 1</code></pre><p>We define a model for the global fit. It takes the global set of parameters <code>p</code> as an input and returns a vector of T₁ estimates that correspond to the T₁ mapping methods described by the vector <code>T1_functions</code></p><pre><code class="language-julia hljs">function model(iseq, p)
    m0s, R1f, R1s = p
    T1 = similar(iseq, Float64)
    Threads.@threads for i in eachindex(iseq)
        T1[i] = T1_functions[iseq[i]](m0s, R1f, R2f, Rx, R1s, T2s)
    end
    return T1
end</code></pre><p>Perform the fit and calculate the simulated T₁:</p><pre><code class="language-julia hljs">fit_Graham = curve_fit(model, 1:length(T1_literature), T1_literature, [m0s, R1f, R1s], x_tol=1e-3)
T1_simulated = model(1:length(T1_literature), fit_Graham.param)</code></pre><p>For this model, the fitted global set of parameters is:</p><pre><code class="language-julia hljs">m0s = fit_Graham.param[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.19446378469746337</code></pre><pre><code class="language-julia hljs">T1f = 1 / fit_Graham.param[2] # s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2.026087604670749</code></pre><pre><code class="language-julia hljs">T1s = 1 / fit_Graham.param[3] # s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.24535283941180797</code></pre><p>The following plot visualizes the quality of the fit and replicates Fig. 1 in the manuscript:</p><pre><code class="language-julia hljs">scatter!(p, T1_simulated, T1_literature, label=&quot;Graham&#39;s model (unconstrained R₁ˢ)&quot;, markershape=marker_list, hover=seq_name)</code></pre><object type="text/html" data="../../plots/967151413.html" style="width:620px;height:620px;"></object><p>Note that clicking on a legend entry removes the fit from the plot. A double click on an entry selects only this particular fit.</p><h3 id="Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-2"><a class="docs-heading-anchor" href="#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-2">Akaike (AIC) and Bayesian (BIC) information criteria</a><a class="docs-heading-anchor-permalink" href="#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-2" title="Permalink"></a></h3><p>The information criteria depend on the number of measurements <code>n</code>, the number of parameters <code>k</code>, and the squared sum of the residuals <code>RSS</code>:</p><pre><code class="language-julia hljs">n = length(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">25</code></pre><pre><code class="language-julia hljs">k = length(fit_Graham.param)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3</code></pre><pre><code class="language-julia hljs">RSS = norm(fit_Graham.resid)^2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.14656258643959397</code></pre><p>With this information, we can calculate the AIC difference to the mono-exponential model:</p><pre><code class="language-julia hljs">ΔAIC = n * log(RSS / n) + 2k - AIC_mono</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-18.580766237337997</code></pre><p>and similarly for the BIC:</p><pre><code class="language-julia hljs">ΔBIC = n * log(RSS / n) + k * log(n) - BIC_mono</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-16.1430145876016</code></pre><h2 id="Sled&#39;s-MT-model-(unconstrained-Rˢ)"><a class="docs-heading-anchor" href="#Sled&#39;s-MT-model-(unconstrained-Rˢ)">Sled&#39;s MT model (unconstrained R₁ˢ)</a><a id="Sled&#39;s-MT-model-(unconstrained-Rˢ)-1"></a><a class="docs-heading-anchor-permalink" href="#Sled&#39;s-MT-model-(unconstrained-Rˢ)" title="Permalink"></a></h2><pre><code class="language-julia hljs">MT_model = Sled()</code></pre><p>The following parameters are hard-coded, except for <code>m0s</code>, <code>R1f</code>, and <code>R1s</code>, which serve as an initialization for the global fit.</p><pre><code class="language-julia hljs">m0s = 0.25
R1f = 1 / 1.84   # 1/s
R1s = 1 / 0.34   # 1/s
R2f = 1 / 0.0769 # 1/s
T2s = 12.5e-6    # s
Rx = 13.6        # 1/s
ω0 = 0
B1 = 1</code></pre><p>We define a model for the global fit. It takes the global set of parameters <code>p</code> as an input and returns a vector of T₁ estimates that correspond to the T₁ mapping methods described by the vector <code>T1_functions</code></p><pre><code class="language-julia hljs">function model(iseq, p)
    m0s, R1f, R1s = p
    T1 = similar(iseq, Float64)
    Threads.@threads for i in eachindex(iseq)
        T1[i] = T1_functions[iseq[i]](m0s, R1f, R2f, Rx, R1s, T2s)
    end
    return T1
end</code></pre><p>Perform the fit and calculate the simulated T₁:</p><pre><code class="language-julia hljs">fit_Sled = curve_fit(model, 1:length(T1_literature), T1_literature, [m0s, R1f, R1s], x_tol=1e-3)
T1_simulated = model(1:length(T1_literature), fit_Sled.param)</code></pre><p>For this model, the fitted global set of parameters is:</p><pre><code class="language-julia hljs">m0s = fit_Sled.param[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.09938220860166001</code></pre><pre><code class="language-julia hljs">T1f = 1 / fit_Sled.param[2] # s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.7045103081206696</code></pre><pre><code class="language-julia hljs">T1s = 1 / fit_Sled.param[3] # s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.11768341516509102</code></pre><p>The following plot visualizes the quality of the fit and replicates Fig. 1 in the manuscript:</p><pre><code class="language-julia hljs">scatter!(p, T1_simulated, T1_literature, label=&quot;Sled&#39;s model (unconstrained R₁ˢ)&quot;, markershape=marker_list, hover=seq_name)</code></pre><object type="text/html" data="../../plots/90790367.html" style="width:620px;height:620px;"></object><p>Note that clicking on a legend entry removes the fit from the plot. A double click on an entry selects only this particular fit.</p><h3 id="Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-3"><a class="docs-heading-anchor" href="#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-3">Akaike (AIC) and Bayesian (BIC) information criteria</a><a class="docs-heading-anchor-permalink" href="#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-3" title="Permalink"></a></h3><p>The information criteria depend on the number of measurements <code>n</code>, the number of parameters <code>k</code>, and the squared sum of the residuals <code>RSS</code>:</p><pre><code class="language-julia hljs">n = length(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">25</code></pre><pre><code class="language-julia hljs">k = length(fit_Sled.param)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3</code></pre><pre><code class="language-julia hljs">RSS = norm(fit_Sled.resid)^2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.13996520972762952</code></pre><p>With this information, we can calculate the AIC difference to the mono-exponential model:</p><pre><code class="language-julia hljs">ΔAIC = n * log(RSS / n) + 2k - AIC_mono</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-19.73223270329035</code></pre><p>and similarly for the BIC:</p><pre><code class="language-julia hljs">ΔBIC = n * log(RSS / n) + k * log(n) - BIC_mono</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-17.29448105355395</code></pre><h2 id="Generalized-Bloch-model-(Rˢ-Rᶠ)"><a class="docs-heading-anchor" href="#Generalized-Bloch-model-(Rˢ-Rᶠ)">Generalized Bloch model (R₁ˢ = R₁ᶠ)</a><a id="Generalized-Bloch-model-(Rˢ-Rᶠ)-1"></a><a class="docs-heading-anchor-permalink" href="#Generalized-Bloch-model-(Rˢ-Rᶠ)" title="Permalink"></a></h2><pre><code class="language-julia hljs">MT_model = gBloch()</code></pre><p>The following parameters are hard-coded, except for <code>m0s</code> and <code>R1f</code>, which serve as an initialization for the global fit.</p><pre><code class="language-julia hljs">m0s = 0.139
R1f = 1 / 1.084  # 1/s
R1s = 1          # 1/s
R2f = 1 / 0.0769 # 1/s
T2s = 12.5e-6    # s
Rx = 23          # 1/s
ω0 = 0
B1 = 1</code></pre><p>We define a model for the global fit. It takes the global set of parameters <code>p</code> as an input and returns a vector of T₁ estimates that correspond to the T₁ mapping methods described by the vector <code>T1_functions</code></p><pre><code class="language-julia hljs">function model(iseq, p)
    m0s, R1f = p
    R1s = R1f
    T1 = similar(iseq, Float64)
    Threads.@threads for i in eachindex(iseq)
        T1[i] = T1_functions[iseq[i]](m0s, R1f, R2f, Rx, R1s, T2s)
    end
    return T1
end</code></pre><p>Perform the fit and calculate the simulated T₁:</p><pre><code class="language-julia hljs">fit_constr = curve_fit(model, 1:length(T1_literature), T1_literature, [m0s, R1f], x_tol=1e-3)
T1_simulated = model(1:length(T1_literature), fit_constr.param)</code></pre><p>For this model, the fitted global set of parameters is:</p><pre><code class="language-julia hljs">m0s = fit_constr.param[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.12881793551863777</code></pre><pre><code class="language-julia hljs">T1f = 1 / fit_constr.param[2] # s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.9742290010278117</code></pre><p>The following plot visualizes the quality of the fit and replicates Fig. 1 in the manuscript:</p><pre><code class="language-julia hljs">scatter!(p, T1_simulated, T1_literature, label=&quot;generalized Bloch model (R₁ˢ = R₁ᶠ constraint)&quot;, markershape=marker_list, hover=seq_name)</code></pre><object type="text/html" data="../../plots/853517863.html" style="width:620px;height:620px;"></object><p>Note that clicking on a legend entry removes the fit from the plot. A double click on an entry selects only this particular fit.</p><h3 id="Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-4"><a class="docs-heading-anchor" href="#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-4">Akaike (AIC) and Bayesian (BIC) information criteria</a><a class="docs-heading-anchor-permalink" href="#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-4" title="Permalink"></a></h3><p>The information criteria depend on the number of measurements <code>n</code>, the number of parameters <code>k</code>, and the squared sum of the residuals <code>RSS</code>:</p><pre><code class="language-julia hljs">n = length(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">25</code></pre><pre><code class="language-julia hljs">k = length(fit_constr.param)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2</code></pre><pre><code class="language-julia hljs">RSS = norm(fit_constr.resid)^2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.17054658474454984</code></pre><p>With this information, we can calculate the AIC difference to the mono-exponential model:</p><pre><code class="language-julia hljs">ΔAIC = n * log(RSS / n) + 2k - AIC_mono</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-16.791867855021792</code></pre><p>and similarly for the BIC:</p><pre><code class="language-julia hljs">ΔBIC = n * log(RSS / n) + k * log(n) - BIC_mono</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-15.5729920301536</code></pre><h2 id="Generalized-Bloch-model-(unconstrained-Rˢ)"><a class="docs-heading-anchor" href="#Generalized-Bloch-model-(unconstrained-Rˢ)">Generalized Bloch model (unconstrained R₁ˢ)</a><a id="Generalized-Bloch-model-(unconstrained-Rˢ)-1"></a><a class="docs-heading-anchor-permalink" href="#Generalized-Bloch-model-(unconstrained-Rˢ)" title="Permalink"></a></h2><pre><code class="language-julia hljs">MT_model = gBloch()</code></pre><p>The following parameters are hard-coded, except for <code>m0s</code>, <code>R1f</code>, and <code>R1s</code>, which serve as an initialization for the global fit.</p><pre><code class="language-julia hljs">m0s = 0.25
R1f = 1 / 1.84   # 1/s
R1s = 1 / 0.34   # 1/s
R2f = 1 / 0.0769 # 1/s
T2s = 12.5e-6    # s
Rx = 13.6        # 1/s
ω0 = 0
B1 = 1</code></pre><p>We define a model for the global fit. It takes the global set of parameters <code>p</code> as an input and returns a vector of T₁ estimates that correspond to the T₁ mapping methods described by the vector <code>T1_functions</code></p><pre><code class="language-julia hljs">function model(iseq, p)
    m0s, R1f, R1s = p
    T1 = similar(iseq, Float64)
    Threads.@threads for i in eachindex(iseq)
        T1[i] = T1_functions[iseq[i]](m0s, R1f, R2f, Rx, R1s, T2s)
    end
    return T1
end</code></pre><p>Perform the fit and calculate the simulated T₁:</p><pre><code class="language-julia hljs">fit_uncon = curve_fit(model, 1:length(T1_literature), T1_literature, [m0s, R1f, R1s], x_tol=1e-3)
T1_simulated = model(1:length(T1_literature), fit_uncon.param)</code></pre><p>For this model, the fitted global set of parameters is:</p><pre><code class="language-julia hljs">m0s = fit_uncon.param[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.20903106717408043</code></pre><pre><code class="language-julia hljs">T1f = 1 / fit_uncon.param[2] # s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2.063020626243208</code></pre><pre><code class="language-julia hljs">T1s = 1 / fit_uncon.param[3] # s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.262550660513381</code></pre><p>The following plot visualizes the quality of the fit and replicates Fig. 1 in the manuscript:</p><pre><code class="language-julia hljs">scatter!(p, T1_simulated, T1_literature, label=&quot;generalized Bloch model (unconstrained R₁ˢ)&quot;, markershape=marker_list, hover=seq_name)</code></pre><object type="text/html" data="../../plots/161594401.html" style="width:620px;height:620px;"></object><p>Note that clicking on a legend entry removes the fit from the plot. A double click on an entry selects only this particular fit.</p><h3 id="Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-5"><a class="docs-heading-anchor" href="#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-5">Akaike (AIC) and Bayesian (BIC) information criteria</a><a class="docs-heading-anchor-permalink" href="#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-5" title="Permalink"></a></h3><p>The information criteria depend on the number of measurements <code>n</code>, the number of parameters <code>k</code>, and the squared sum of the residuals <code>RSS</code>:</p><pre><code class="language-julia hljs">n = length(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">25</code></pre><pre><code class="language-julia hljs">k = length(fit_uncon.param)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3</code></pre><pre><code class="language-julia hljs">RSS = norm(fit_uncon.resid)^2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.11479629307483916</code></pre><p>With this information, we can calculate the AIC difference to the mono-exponential model:</p><pre><code class="language-julia hljs">ΔAIC = n * log(RSS / n) + 2k - AIC_mono</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-24.6881001209606</code></pre><p>and similarly for the BIC:</p><pre><code class="language-julia hljs">ΔBIC = n * log(RSS / n) + k * log(n) - BIC_mono</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-22.2503484712242</code></pre><h2 id="Data-analysis"><a class="docs-heading-anchor" href="#Data-analysis">Data analysis</a><a id="Data-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Data-analysis" title="Permalink"></a></h2><p>The span of T₁ estimates in the literature is</p><pre><code class="language-julia hljs">extrema(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.64, 1.0855)</code></pre><p>and the coefficient of variation is</p><pre><code class="language-julia hljs">variation(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.1408807728048427</code></pre><h3 id="Median-absolute-deviation"><a class="docs-heading-anchor" href="#Median-absolute-deviation">Median absolute deviation</a><a id="Median-absolute-deviation-1"></a><a class="docs-heading-anchor-permalink" href="#Median-absolute-deviation" title="Permalink"></a></h3><p>In the paper, the median absolute deviation from the mean value is used, as it is more robust to outliers compared to the mean absolute deviation or the standard deviation. Note, however, that the median absolute deviation of the mono-exponential fit is dominated by an outlier, artificially inflating the corresponding reduction.</p><p>A mono-exponential model explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - mad(fit_mono.resid; center=mean(fit_mono.resid)) / mad(T1_literature; center=mean(T1_literature))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.07118935312824093</code></pre><p>Graham&#39;s spectral model without constraints on <code>R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - mad(fit_Graham.resid; center=mean(fit_Graham.resid)) / mad(T1_literature; center=mean(T1_literature))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.6071335860151669</code></pre><p>Sled&#39;s model without constraints on <code>R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - mad(fit_Sled.resid; center=mean(fit_Sled.resid)) / mad(T1_literature; center=mean(T1_literature))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.5567822162017504</code></pre><p>The generalized Bloch model constrained by <code>R₁ˢ = R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - mad(fit_constr.resid; center=mean(fit_constr.resid)) / mad(T1_literature; center=mean(T1_literature))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.4684203732531683</code></pre><p>The generalized Bloch model without constraints on <code>R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - mad(fit_uncon.resid; center=mean(fit_uncon.resid)) / mad(T1_literature; center=mean(T1_literature))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.6171961683507089</code></pre><h3 id="Mean-absolute-deviation"><a class="docs-heading-anchor" href="#Mean-absolute-deviation">Mean absolute deviation</a><a id="Mean-absolute-deviation-1"></a><a class="docs-heading-anchor-permalink" href="#Mean-absolute-deviation" title="Permalink"></a></h3><p>For comparison, the mean absolute deviation is analyzed: A mono-exponential model explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - mean(abs.(fit_mono.resid .- mean(fit_mono.resid))) / mean(abs.(T1_literature .- mean(T1_literature)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.023426403041203026</code></pre><p>Graham&#39;s spectral model without constraints on <code>R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - mean(abs.(fit_Graham.resid .- mean(fit_Graham.resid))) / mean(abs.(T1_literature .- mean(T1_literature)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.4834831199140681</code></pre><p>Sled&#39;s model without constraints on <code>R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - mean(abs.(fit_Sled.resid .- mean(fit_Sled.resid))) / mean(abs.(T1_literature .- mean(T1_literature)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.48265447199825884</code></pre><p>The generalized Bloch model constrained by <code>R₁ˢ = R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - mean(abs.(fit_constr.resid .- mean(fit_constr.resid))) / mean(abs.(T1_literature .- mean(T1_literature)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.42795873321794164</code></pre><p>The generalized Bloch model without constraints on <code>R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - mean(abs.(fit_uncon.resid .- mean(fit_uncon.resid))) / mean(abs.(T1_literature .- mean(T1_literature)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.5261587981865726</code></pre><h3 id="Standard-deviation"><a class="docs-heading-anchor" href="#Standard-deviation">Standard deviation</a><a id="Standard-deviation-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-deviation" title="Permalink"></a></h3><p>For comparison, the standard deviation is analyzed: A mono-exponential model explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - std(fit_mono.resid) / std(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.01826093355907199</code></pre><p>Graham&#39;s spectral model without constraints on <code>R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - std(fit_Graham.resid) / std(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.37502858305844344</code></pre><p>Sled&#39;s spectral model without constraints on <code>R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - std(fit_Sled.resid) / std(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.38924942271187124</code></pre><p>The generalized Bloch model constrained by <code>R₁ˢ = R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - std(fit_constr.resid) / std(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.32587111172659133</code></pre><p>The generalized Bloch model without constraints on <code>R₁ᶠ</code> explains the following fraction of the T₁ variability in the literature:</p><pre><code class="language-julia hljs">1 - std(fit_uncon.resid) / std(T1_literature)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.4468849451044564</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../T1_mapping_methods/">« T₁-mapping methods</a><a class="docs-footer-nextpage" href="../helper_functions/">Helper functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 17 September 2025 03:38">Wednesday 17 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
