var documenterSearchIndex = {"docs":
[{"location":"build_literate/Derivaties/#Sensitivity-analysis","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"","category":"section"},{"location":"build_literate/Derivaties/#Load-code","page":"Sensitivity analysis","title":"Load code","text":"","category":"section"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"First, we load the required packages and include some Helper functions:","category":"page"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"include(\"helper_functions.jl\")\ninclude(\"Derivatives_HelperFunctions.jl\")\nnothing #hide","category":"page"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"load all T₁-mapping methods:","category":"page"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"include(\"T1_mapping_methods.jl\")\nnothing #hide","category":"page"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"All simulations in this analysis are performed with the generalized Bloch model:","category":"page"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"MT_model = gBloch()\nnothing #hide","category":"page"},{"location":"build_literate/Derivaties/#Set-parameters","page":"Sensitivity analysis","title":"Set parameters","text":"","category":"section"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"We analyze overall 9 ROIs and use the MT parameters from the paper Unconstrained quantitative magnetization transfer imaging: Disentangling T₁ of the free and semi-solid spin pools:","category":"page"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"ROI = [:WM, :anteriorCC, :posteriorCC, :GM, :Caudate, :Putamen, :Pallidum, :Thalamus, :Hippocampus]\nm0s = [0.212, 0.237, 0.235, 0.098, 0.113, 0.118, 0.164, 0.158, 0.097]\nT1f = [1.84, 1.77, 1.80, 2.46, 1.95, 1.84, 1.664, 2.02, 2.65]\nT2f = [76.9, 69.9, 76.3, 83, 73.3, 67.4, 59.3, 70.8, 91] .* 1e-3\nRex = [13.6, 13.4, 13.5, 14.0, 13.8, 14.9, 15.8, 14.2, 15.3]\nT1s = [0.34, 0.349, 0.350, 0.42, 0.432, 0.385, 0.351, 0.396, 0.376]\nT2s = [12.5, 14.5, 12.6, 14.4, 15.1, 15.4, 14.9, 13.0, 13.0]\nnothing #hide","category":"page"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"For consistency, we use times instead of rates throughout","category":"page"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"Tex = 1 ./ Rex\nnothing #hide","category":"page"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"and we neglect B₀ and B₁ inhomogeneities:","category":"page"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"ω0 = 0\nB1 = 1\nnothing #hide","category":"page"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"We define vectors of symbols for all MT parameters and the derivatives ∂T₁ᵒ/∂pⱼᴹᵀ:","category":"page"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"p = [:m0s, :T1f, :T2f, :Tex, :T1s, :T2s]\nj = [:dT1odm0s, :dT1odT1f, :dT1odT2f, :dT1odTex, :dT1odT1s, :dT1odT2s]\nnothing #hide","category":"page"},{"location":"build_literate/Derivaties/#Compute-derivatives","page":"Sensitivity analysis","title":"Compute derivatives","text":"","category":"section"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"Since the calculation of the derivatives is computationally intensive, it is pre-computed and saved in a CSV file. To recompute the derivatives, set the following parameter to true:","category":"page"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"calculate_jacobian = false\nnothing #hide","category":"page"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"We store all derivatives in a DataFrame list (saved in the file jacobian.csv), concatenating ROIs and T₁ mapping methods:","category":"page"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"Nrows = length(ROI) * length(T1_functions)\n\nif calculate_jacobian\n    df = DataFrame(\n        seq_name=Vector{String}(undef, Nrows),\n        seq_type=Vector{Symbol}(undef, Nrows),\n        ROI=Vector{Symbol}(undef, Nrows),\n        m0s=Vector{Float64}(undef, Nrows),\n        T1f=Vector{Float64}(undef, Nrows),\n        T2f=Vector{Float64}(undef, Nrows),\n        Tex=Vector{Float64}(undef, Nrows),\n        T1s=Vector{Float64}(undef, Nrows),\n        T2s=Vector{Float64}(undef, Nrows),\n        dT1odm0s=Vector{Float64}(undef, Nrows),\n        dT1odT1f=Vector{Float64}(undef, Nrows),\n        dT1odT2f=Vector{Float64}(undef, Nrows),\n        dT1odTex=Vector{Float64}(undef, Nrows),\n        dT1odT1s=Vector{Float64}(undef, Nrows),\n        dT1odT2s=Vector{Float64}(undef, Nrows),\n    )\n\n    Threads.@threads for iROI ∈ eachindex(ROI)\n        _p = (m0s[iROI], T1f[iROI], T2f[iROI], Tex[iROI], T1s[iROI], T2s[iROI])\n        Threads.@threads for iseq ∈ eachindex(T1_functions)\n            df_idx = iseq + length(T1_functions) * (iROI - 1)\n\n            # The following line performs the actual computation of the derivatives.\n            # `T1_functions` takes the rates of several MT parameters, so we have to call it with `1/T`.\n            # `T₂ˢ` is rescaled to ensure stability of the finite difference algorithm.\n            j = jacobian(central_fdm(5, 1), p -> T1_functions[iseq](p[1], 1 / p[2], 1 / p[3], 1 / p[4], 1 / p[5], 1e-6p[6]), _p)[1]\n\n            df[df_idx, :seq_name] = seq_name[iseq]\n            df[df_idx, :seq_type] = seq_type[iseq]\n            df[df_idx, :ROI] = ROI[iROI]\n            df[df_idx, :m0s] = m0s[iROI]\n            df[df_idx, :T1f] = T1f[iROI]\n            df[df_idx, :T2f] = T2f[iROI]\n            df[df_idx, :Tex] = Tex[iROI]\n            df[df_idx, :T1s] = T1s[iROI]\n            df[df_idx, :T2s] = T2s[iROI]\n            df[df_idx, :dT1odm0s] = j[1]\n            df[df_idx, :dT1odT1f] = j[2]\n            df[df_idx, :dT1odT2f] = j[3]\n            df[df_idx, :dT1odTex] = j[4]\n            df[df_idx, :dT1odT1s] = j[5]\n            df[df_idx, :dT1odT2s] = j[6]\n        end\n    end\n    CSV.write(\"$(get_main_path())/jacobian.csv\", df)\nelse\n    df = DataFrame(CSV.File(\"$(get_main_path())/jacobian.csv\"))\nend\nshow(df; allrows=false, allcols=true)","category":"page"},{"location":"build_literate/Derivaties/#Figure-1","page":"Sensitivity analysis","title":"Figure 1","text":"","category":"section"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"Fig. 1 is a scatter plot and _x ensures the desired alignment along the x-axis and ymax ensures a uniform scaling of the plot:","category":"page"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"_x = Float64.(map(x -> findfirst(isequal(x), unique(df.ROI)), df.ROI))\n_x .+= (map(x -> findfirst(isequal(x), sort(unique(df.seq_type))), df.seq_type) .- 3) ./ 8\nymax = maximum([maximum(abs.(df[!, j[i]] .* mean(df[!, p[i]]))) for i ∈ eachindex(j)]) * 1.1\nnothing #hide","category":"page"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"pall = similar(j, Plots.Plot)\nylabels = [\"|∂T₁ᵒ/∂m₀ˢ⋅μ(m₀ˢ)| (s)\", \"|∂T₁ᵒ/∂T₁ᶠ⋅μ(T₁ᶠ)| (s)\", \"|∂T₁ᵒ/∂T₂ᶠ⋅μ(T₂ᶠ)| (s)\", \"|∂T₁ᵒ/∂Tₓ⋅μ(Tₓ)| (s)\", \"|∂T₁ᵒ/∂T₁ˢ⋅μ(T₁ˢ)| (s)\", \"|∂T₁ᵒ/∂T₂ˢ⋅μ(T₂ˢ)| (s)\"]\nfor id ∈ eachindex(j)\n    pall[id] = scatter(_x, abs.(df[!, j[id]] .* mean(df[!, p[id]])),\n        group=df.seq_type,\n        hover=df.seq_name,\n        xticks=id == length(j) ? (1:9, String.(unique(df.ROI))) : (1:9, [\"\" for _ ∈ 1:9]),\n        ylim=(0, ymax),\n        ylabel=ylabels[id],\n        legend_position=:none,\n    )\nend\nplt = plot(pall..., layout=(6, 1), size=(800, 1500))\nMain.HTMLPlot(plt) #hide","category":"page"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"Derivatives of the observed T₁ᵒ with respect to the 6 MT parameters. I calculated the derivatives for 9 brain regions of interest (ROIs) and for 25 pulse sequences, grouped into different sequence types (cf. legend). Here, WM denotes white matter, CC the corpus callosum, and GM gray matter. The derivatives ∂T₁ᵒ/∂pᵢᴹᵀ are normalized by pᵢᴹᵀ, averaged over all ROIs, to allow for a comparison between the parameters.","category":"page"},{"location":"build_literate/Derivaties/#Linear-Mixed-model","page":"Sensitivity analysis","title":"Linear Mixed model","text":"","category":"section"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"First, we initialize a few empty DataFrame objects that are filled in the for-loop.","category":"page"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"df_pred = DataFrame(\n    dT1odm0s_observe=Vector{Float64}(undef, Nrows),\n    dT1odT1f_observe=Vector{Float64}(undef, Nrows),\n    dT1odT2f_observe=Vector{Float64}(undef, Nrows),\n    dT1odTex_observe=Vector{Float64}(undef, Nrows),\n    dT1odT1s_observe=Vector{Float64}(undef, Nrows),\n    dT1odT2s_observe=Vector{Float64}(undef, Nrows),\n    dT1odm0s_predict=Vector{Float64}(undef, Nrows),\n    dT1odT1f_predict=Vector{Float64}(undef, Nrows),\n    dT1odT2f_predict=Vector{Float64}(undef, Nrows),\n    dT1odTex_predict=Vector{Float64}(undef, Nrows),\n    dT1odT1s_predict=Vector{Float64}(undef, Nrows),\n    dT1odT2s_predict=Vector{Float64}(undef, Nrows),\n    color=Vector{Int}(undef, Nrows),\n    ROI=Vector{Symbol}(undef, Nrows),\n)\n\nr2 = DataFrame()\nr2[!, Symbol(\"∂T₁ᵒ / ∂pᵢᴹᵀ\")]=Symbol[]\nr2[!, Symbol(\"μ(∂T₁ᵒ/∂pᵢᴹᵀ) ⋅ μ(pᵢᴹᵀ)\")]=Float64[]\nr2[!, Symbol(\"σ(∂T₁ᵒ/∂pᵢᴹᵀ) / μ(∂T₁ᵒ/∂pᵢᴹᵀ)\")]=Float64[]\nr2[!, Symbol(\"R²(fixed)\")]=Float64[]\nr2[!, Symbol(\"R²(ROI)\")]=Float64[]\nr2[!, Symbol(\"R²(seq. type)\")]=Float64[]\nr2[!, Symbol(\"R²(ind. seq)\")]=Float64[]\nr2[!, Symbol(\"R²(full)\")]=Float64[]\n\nr2_fixed = DataFrame()\nr2_fixed[!, Symbol(\"∂T₁ᵒ / ∂pᵢᴹᵀ\")]=Symbol[]\nr2_fixed[!, Symbol(\"R²(m₀ˢ)\")]=Float64[]\nr2_fixed[!, Symbol(\"R²(T₁ᶠ)\")]=Float64[]\nr2_fixed[!, Symbol(\"R²(T₂ᶠ)\")]=Float64[]\nr2_fixed[!, Symbol(\"R²(Tₓ)\")]=Float64[]\nr2_fixed[!, Symbol(\"R²(T₁ˢ)\")]=Float64[]\nr2_fixed[!, Symbol(\"R²(T₂ˢ)\")]=Float64[]\nr2_fixed[!, Symbol(\"R²(fixed)\")]=Float64[]\n\nfixed_model = DataFrame()\nfixed_model[!, Symbol(\"∂T₁ᵒ / ∂pᵢᴹᵀ\")]=Symbol[]\nfixed_model[!, Symbol(\"a₀\")]=Float64[]\nfixed_model[!, Symbol(\"a(m₀ˢ)\")]=Float64[]\nfixed_model[!, Symbol(\"a(T₁ᶠ) (1/s)\")]=Float64[]\nfixed_model[!, Symbol(\"a(T₂ᶠ) (1/s)\")]=Float64[]\nfixed_model[!, Symbol(\"a(Tₓ) (1/s)\")]=Float64[]\nfixed_model[!, Symbol(\"a(T₁ˢ) (1/s)\")]=Float64[]\nfixed_model[!, Symbol(\"a(T₂ˢ) (1/s)\")]=Float64[]\nfixed_model[!, Symbol(\"m₀ˢ = 0\")]=Float64[]\n\n\npall = similar(j, Plots.Plot)\nfor id ∈ eachindex(j)\n    μⱼ = abs(mean(df[!, j[id]]) * mean(df[!, p[id]]))\n    cv = abs(std(df[!, j[id]]) / mean(df[!, j[id]]))\n\n    frm = @formula(derivative ~ 1 + m0s + T1f + T2f + Tex + T1s + T2s + (1 | seq_type) + (1 | seq_name) + (1 | ROI))\n    model = fit(MixedModel, term(j[id]) ~ frm.rhs, df)\n\n    pred = sum(param -> model.βs[param] .* df[!, param], Symbol.(frm.rhs[collect(typeof.(frm.rhs) .== Term)]))\n    σ²_fixed = var(pred; corrected=false)\n\n    σ²_ROI = model.σs[:ROI][1]^2\n    σ²_seqname = model.σs[:seq_name][1]^2\n    σ²_seqtype = model.σs[:seq_type][1]^2\n    σ²_ϵ = model.σ^2\n    σ²_all = σ²_fixed + σ²_ROI + σ²_seqtype + σ²_seqname + σ²_ϵ\n\n    r²_fixed = σ²_fixed / σ²_all\n    r²_ROI = σ²_ROI / σ²_all\n    r²_seqname = σ²_seqname / σ²_all\n    r²_seqtype = σ²_seqtype / σ²_all\n    r²_full = (σ²_fixed + σ²_ROI + σ²_seqtype + σ²_seqname) / σ²_all\n\n    fe = fixef(model)\n    m0s_intercept = fe[1] + mean(df.T1f) * fe[3] + mean(df.T2f) * fe[4] + mean(df.Tex) * fe[5] + mean(df.T1s) * fe[6] + mean(df.T2s) * fe[7]\n\n    push!(r2, (j[id], μⱼ, cv, r²_fixed, r²_ROI, r²_seqtype, r²_seqname, r²_full))\n\n    Δr² = shapley_regression(df, j[id], p)\n    push!(r2_fixed, (j[id], Δr²..., sum(Δr²)))\n\n    push!(fixed_model, (j[id], fe..., m0s_intercept))\n\n\n    # Plot: observed vs full-model prediction\n    dlim = maximum(df[!, j[id]]) - minimum(df[!, j[id]])\n    xlim = (minimum(df[!, j[id]]) - 0.15dlim, maximum(df[!, j[id]]) + 0.15dlim)\n\n    available_markers = [:circle, :rect, :diamond, :hexagon, :cross, :xcross, :utriangle, :x, :dtriangle]\n    unique_ROI = unique(df.ROI)\n    label_to_marker = Dict(label => available_markers[i] for (i, label) in enumerate(unique_ROI))\n    markers = [label_to_marker[label] for label in df.ROI]\n\n    pall[id] = scatter(df[!, j[id]], predict(model);\n        group=df.seq_type,\n        hover=df.seq_name .* df.ROI,\n        m=markers,\n        title = j[id],\n        xlabel=id ∈ [5,6] ? \"Observed\" : \"\",\n        ylabel=id ∈ [1,3,5] ? \"Predicted\" : \"\",\n        legend=:none,\n        xlim,\n        ylim=xlim\n    )\n\n    plot!(pall[id], [xlim...], [xlim...], label=\"Ideal\", lc=:white, ls=:dash)\nend","category":"page"},{"location":"build_literate/Derivaties/#Table-1:","page":"Sensitivity analysis","title":"Table 1:","text":"","category":"section"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"Print the results of the mixed effects model fit:","category":"page"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"r2","category":"page"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"This table corresponds to Tab. 1 in the paper. The column μ(∂T₁ᵒ/∂pᵢᴹᵀ) ⋅ μ(pᵢᴹᵀ) denotes the mean derivative, normalized by the average parameter, and serves as a measure for the sensitivity of T₁ᵒ to the respective parameter. The column σ(∂T₁ᵒ/∂pᵢᴹᵀ) / μ(∂T₁ᵒ/∂pᵢᴹᵀ) denotes the coefficient of variation. The coefficients of determination for the full model R^2(full) is dissected into its components: R^2(full) = R²(fixed) + R^2(ROI) + R^2(seq. type) + R^2(ind. seq), where R²(fixed) captures all fixed effects, that is, the degree to which variations of the pᵢᴹᵀ between the ROIs explain the derivatives' variability. R^2(ROI) captures the ROI-identifier as a random variable, potentially modeling inter-ROI variations not captured by the linear model of pᵢᴹᵀ. R^2(seq. type) captures the degree to which the sequence type, that is, the groups inversion-recovery, Look-Locker, saturation-recovery, variable flip angle, and MP²RAGE, explains variability of the derivatives, and R^2(ind. seq) captures each sequence by itself.","category":"page"},{"location":"build_literate/Derivaties/#Table-2:","page":"Sensitivity analysis","title":"Table 2:","text":"","category":"section"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"r2_fixed","category":"page"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"This table corresponds to Tab. 2 in the paper and analyzes the fixed effects. R²(fixed) is separated into the individual effects with Shapley regression. Note that `R²(fixed) = R²(m₀ˢ) + R²(T₁ᶠ) + R²(T₂ᶠ) + R²(Tₓ) + R²(T₁ˢ) + R²(T₂ˢ).","category":"page"},{"location":"build_literate/Derivaties/#Figure-2","page":"Sensitivity analysis","title":"Figure 2","text":"","category":"section"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"plt = plot(pall..., layout=(3, 2), size=(800, 1200))\nMain.HTMLPlot(plt) #hide","category":"page"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"Validation of the mixed effects model, where \"observed\" denotes the simulated derivatives, and \"predicted\" the output of the mixed model. The sequence type is here color-coded, while the maker shape identifies the region of interest. Here, WM denotes white matter, CC the corpus callosum, and GM gray matter. The dotted line represents the perfect fit.","category":"page"},{"location":"build_literate/Derivaties/#Table-A1:","page":"Sensitivity analysis","title":"Table A1:","text":"","category":"section"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"fixed_model","category":"page"},{"location":"build_literate/Derivaties/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"Coefficients of the fixed effects for each derivative's mixed model fit, including the intercept a₀. The last column denotes the derivatives assuming m₀ˢ = 0 and the mean values for the other parameters. For m₀ˢ = 0, the MT model reduces to the Bloch model, and a perfect statistical model should result in ∂T₁ᵒ/∂T₁ᶠ = 1 and ∂T₁ᵒ/∂Tₓ = ∂T₁ᵒ/∂T₁ˢ = ∂T₁ᵒ/∂T₂ˢ = 0. This is clearly not the case, highlighting the limitations of the mixed-effects model when extrapolating.","category":"page"},{"location":"build_literate/helper_functions/#Helper-functions","page":"Helper functions","title":"Helper functions","text":"","category":"section"},{"location":"build_literate/helper_functions/#Load-packages","page":"Helper functions","title":"Load packages","text":"","category":"section"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"using MRIgeneralizedBloch\nusing StaticArrays\nusing Statistics\nusing QuadGK\nusing DifferentialEquations\nusing SpecialFunctions\nusing LinearAlgebra\nusing DataFrames\nusing StatsBase\nusing LsqFit\nusing ApproxFun\nusing Plots\nplotlyjs(bg=RGBA(31 / 255, 36 / 255, 36 / 255, 1.0), ticks=:native, size=(600, 600))\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/#Define-MT-models","page":"Helper functions","title":"Define MT models","text":"","category":"section"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"These structs are used to identify the MT model with Julia's multiple dispatch mechanism","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"struct gBloch end\nstruct Graham end\nstruct Sled end\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/#Spoiler-propagator","page":"Helper functions","title":"Spoiler propagator","text":"","category":"section"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"This matrix implements \"perfect\" RF spoiling that destroys all transversal magnetization.","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"u_sp = @SMatrix [\n    0 0 0 0 0 0\n    0 0 0 0 0 0\n    0 0 1 0 0 0\n    0 0 0 0 0 0\n    0 0 0 0 1 0\n    0 0 0 0 0 1]\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/#Steady-state","page":"Helper functions","title":"Steady state","text":"","category":"section"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"The input U of this function is a matrix that describes the spin evolution during an RF pulse sequence. The function uses linear algebra to calculate the steady state magnetization m resulting from repeated execution of the pulse sequence described by U.","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"function steady_state(U)\n    U0 = @SMatrix [\n        1 0 0 0 0 0;\n        0 1 0 0 0 0;\n        0 0 1 0 0 0;\n        0 0 0 1 0 0;\n        0 0 0 0 1 0;\n        0 0 0 0 0 0]\n    Q = U - U0\n    m = Q \\ @SVector [0,0,0,0,0,1]\n    return m\nend\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/#RF-pulse-propagators","page":"Helper functions","title":"RF pulse propagators","text":"","category":"section"},{"location":"build_literate/helper_functions/#Generalized-Bloch-model","page":"Helper functions","title":"Generalized Bloch model","text":"","category":"section"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"First, we pre-calculate the linearization of the generalized Bloch model. Refer to the documentation of the generalized Bloch package for details.","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"const G = interpolate_greens_function(greens_superlorentzian, 0, 1000)\nconst R2sl_1 = precompute_R2sl(TRF_min=1e-6, TRF_max=3e-6, ω1_max=π / 500e-6, T2s_min=12e-6, T2s_max=17e-6, B1_max=1.1)[1]\nconst R2sl_2 = precompute_R2sl(TRF_min=10e-6, TRF_max=20e-6, ω1_max=π / 10e-6, T2s_min=12e-6, T2s_max=17e-6, B1_max=1.1)[1]\nconst R2sl_3 = precompute_R2sl(TRF_max=1e-3, ω1_max=π / 500e-6, T2s_min=12e-6, T2s_max=17e-6, B1_max=1.1)[1]\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"We implemented different methods for the function RF_pulse_propagator that inferred with Julia's multiple dispatch logic based on the type of the input parameters. The functions in this section take the variable model of type gBloch and implement the generalized Bloch model. The first method further takes the variable ω1 of the abstract type Number, i.e., it implements pulse propagators for a constant ω₁.","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"function RF_pulse_propagator(ω1::Number, B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, T2s, model::gBloch; spoiler=true)\n    if TRF >= 1e-6 && TRF <= 3e-6\n        R2s = R2sl_1(TRF, abs(ω1 * TRF), B1, T2s)\n        U = exp(hamiltonian_linear(ω1, B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, R2s))\n        U = spoiler ? U * u_sp : U\n    elseif TRF >= 10e-6 && TRF <= 20e-6\n        R2s = R2sl_2(TRF, abs(ω1 * TRF), B1, T2s)\n        U = exp(hamiltonian_linear(ω1, B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, R2s))\n        U = spoiler ? U * u_sp : U\n    elseif TRF >= 100e-6 && TRF <= 1e-3\n        R2s = R2sl_3(TRF, abs(ω1 * TRF), B1, T2s)\n        U = exp(hamiltonian_linear(ω1, B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, R2s))\n        U = spoiler ? U * u_sp : U\n    else\n        U = RF_pulse_propagator(_ -> ω1, B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, T2s, model; spoiler=spoiler)\n    end\n    return U\nend\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"The following method takes the variable ω1 of type Function, i.e., it implements pulse propagators with a variable ω₁ that is implemented as the function ω1(t):","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"function RF_pulse_propagator(ω1::Function, B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, T2s, model::gBloch; spoiler=true)\n    U = zeros(6, 6)\n    Ui = @view U[[1:3; 5:6], [1:3; 5:6]]\n\n    i_in = spoiler ? (3:5) : (1:5) # if a spoiler precedes the pulse, only the z magnetization is non-zero\n    Threads.@threads for i ∈ i_in\n        m0 = zeros(5)\n        m0[i] = 1\n        mfun(p, t; idxs=nothing) = typeof(idxs) <: Number ? m0[idxs] : m0\n        Ui[1:5, i] = solve(DDEProblem(apply_hamiltonian_gbloch!, m0, mfun, (0, TRF), (ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, G)), reltol=1e-6, MethodOfSteps(RK4()))[end]\n    end\n    return U\nend\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/#Graham's-model","page":"Helper functions","title":"Graham's model","text":"","category":"section"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"function RF_pulse_propagator(ω1::Number, B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, T2s, model::Graham; spoiler=true)\n    m0 = zeros(5)\n    U = zeros(6, 6)\n    Ui = @view U[[1:3; 5:6], [1:3; 5:6]]\n\n    i_in = spoiler ? (3:5) : (1:5) # if a spoiler precedes the pulse, only the z magnetization is non-zero\n    for i ∈ i_in\n        m0 .= 0\n        m0[i] = 1\n        Ui[1:5, i] = solve(ODEProblem(apply_hamiltonian_graham_superlorentzian!, m0, (0, TRF), (ω1, B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, T2s)), Vern9(), reltol=1e-6)[end]\n    end\n    return U\nend\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"function RF_pulse_propagator(ω1::Function, B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, T2s, model::Graham; spoiler=true)\n    Rrf = graham_saturation_rate_spectral_fast(ω1, B1, ω0, TRF, T2s)\n\n    m0 = zeros(5)\n    U = zeros(6, 6)\n    Ui = @view U[[1:3; 5:6], [1:3; 5:6]]\n\n    i_in = spoiler ? (3:5) : (1:5) # if a spoiler precedes the pulse, only the z magnetization is non-zero\n    for i ∈ i_in\n        m0 .= 0\n        m0[i] = 1\n        Ui[1:5, i] = solve(ODEProblem(apply_hamiltonian_linear!, m0, (0, TRF), (ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, Rrf)), Vern9(), reltol=1e-6)[end]\n    end\n    return U\nend\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/#Sled's-model","page":"Helper functions","title":"Sled's model","text":"","category":"section"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"function RF_pulse_propagator(ω1, B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, T2s, model::Sled; spoiler=true)\n    m0 = zeros(5)\n    U = zeros(6, 6)\n    Ui = @view U[[1:3; 5:6], [1:3; 5:6]]\n\n    i_in = spoiler ? (3:5) : (1:5) # if a spoiler precedes the pulse, only the z magnetization is non-zero\n    for i ∈ i_in\n        m0 .= 0\n        m0[i] = 1\n        mfun(p, t; idxs=nothing) = typeof(idxs) <: Number ? m0[idxs] : m0\n        Ui[1:5, i] = solve(ODEProblem(apply_hamiltonian_sled!, m0, (0, TRF), (ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, G)), Vern9(), reltol=1e-6)[end]\n    end\n    return U\nend\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/#Helper-functions-for-Graham's-spectral-model","page":"Helper functions","title":"Helper functions for Graham's spectral model","text":"","category":"section"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"The following code saves and reuses the saturation rate Rrf of an RF pulse to speed up the simulation.","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"struct Rrf_Atom\n    ω1_sqrtTRF::Float64\n    ω1_TRFo2::Float64\n    ω1_TRFmsqrtTRF::Float64\n    B1::Float64\n    ω0::Float64\n    TRF::Float64\n    T2s::Float64\n    Rrf::Float64\nend\nRrf_Dict = Rrf_Atom[]\nfunction graham_saturation_rate_spectral_fast(ω1, B1, ω0, TRF, T2s)\n    T2s == 0 && return 1 # for mono-exponential model\n\n    d_ω0 = typeof(ω0) <: Function ? ω0(sqrt(TRF)) : ω0 # just used for comparison\n\n    for x ∈ Rrf_Dict\n        if ω1(sqrt(TRF)) == x.ω1_sqrtTRF && ω1(TRF/2) == x.ω1_TRFo2 && ω1(TRF-sqrt(TRF)) == x.ω1_TRFmsqrtTRF && B1 == x.B1 && d_ω0 == x.ω0 && TRF == x.TRF && T2s == x.T2s\n            return x.Rrf\n        end\n    end\n\n    Rrf = graham_saturation_rate_spectral(ω0_int -> lineshape_superlorentzian(ω0_int, T2s), t -> ω1(t)*B1, TRF, ω0)\n    push!(Rrf_Dict, Rrf_Atom(ω1(sqrt(TRF)), ω1(TRF/2), ω1(TRF-sqrt(TRF)), B1, d_ω0, TRF, T2s, Rrf))\n    return Rrf\nend\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/#RF-pulse-definitions","page":"Helper functions","title":"RF pulse definitions","text":"","category":"section"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"function sinc_pulse(α, TRF; nLobes=3)\n    nLobes % 2 != 1 ? error() : nothing\n    x = (nLobes - 1) / 2 + 1\n    ω1(t) = sinc((2t / TRF - 1) * x) * α * x * π / (sinint(x * π) * TRF)\nend\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"function hanning_pulse(α, TRF)\n    ω1(t) = α * cos(π * t / TRF - π / 2)^2 * 2 / TRF\nend\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"function gauss_pulse(α, TRF; shape_alpha=2.5)\n    y(t) = exp(-((2 * t / TRF - 1) * shape_alpha)^2 / 2)\n    ω1(t) = α * (y(t) - y(0)) / (sqrt(π/2) * TRF * erf(shape_alpha/sqrt(2)) / shape_alpha - y(0)*TRF)\nend\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"Controlled saturation MT pulse as described by Teixeira et al. (2019):","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"function CSMT_pulse(α, TRF, TR, ω1rms; ω0=12000π)\n    ω1_0 = gauss_pulse(α, TRF; shape_alpha=2.5) # shape & shape_alpha confirmed by Dr. Teixeira\n    ω1ms_0 = quadgk(t -> ω1_0(t)^2, 0, TRF)[1] / TR\n\n    β = ω1rms^2 / ω1ms_0 - 1\n    if β < 0\n        β = 0\n        @error \"negative Δω1ms with α = $(α*180/pi)deg; on-resonant pulse has ω1rms = $(sqrt(ω1ms_0)). Setting it to zero.\"\n    end\n\n    wt(t) = 1 - sqrt(2 * β) * cos(ω0 * t)\n    ω1(t) = ω1_0(t) * wt(t)\n    return ω1\nend\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"function sech_inversion_pulse(; TRF=10.24e-3, ω₁ᵐᵃˣ=4965.910769033364, μ=5, β=674.1)\n    ω1(t) = ω₁ᵐᵃˣ * sech(β * (t - TRF / 2)) # rad/s\n    ω0(t) = -μ * β * tanh(β * (t - TRF/2)) # rad/s\n    φ_u(t) = μ * log(cosh(β * t) - sinh(β * t) * tanh(β * TRF / 2)) # rad\n    φ(t) = φ_u(t) - φ_u(TRF/2)\n    return (ω1, ω0, φ, TRF)\nend\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"Sechn pulse shape according to this paper, confirmed by Dr. O'Brien:","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"function sechn_inversion_pulse(; TRF=10.24e-3, ω₁ᵐᵃˣ=10e-6 * 267.522e6, β=240, μ=35, n = 8)\n    f1(τ) = sech((β * τ)^n)\n    ω1(t) = ω₁ᵐᵃˣ * f1(t - TRF / 2) # rad/s\n\n    ω0_i(t) = μ * β^2 * quadgk((τ) -> f1(τ)^2, 0, t - TRF/2)[1]\n    ω0 = Fun(ω0_i, 0..TRF)\n    φ_ = cumsum(ω0)\n    φ(t) = φ_(t) - φ_(TRF/2)\n    return (ω1, ω0, φ, TRF)\nend\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/#T-mapping-methods","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"","category":"section"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"First, we initialize a few empty vectors which will be filled with information about each T₁-mapping method:","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"T1_literature = Float64[]\nT1_functions = []\nincl_fit = Bool[]\nseq_name = String[]\nseq_type = Symbol[]\nusing GLM #hide\nusing StaticArrays #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"Next, we define the simulations of each pulse sequence as a function and push this function and auxiliary information for plotting to the respective vector.","category":"page"},{"location":"build_literate/T1_mapping_methods/#IR:-Stanisz-et-al.","page":"T₁-mapping methods","title":"IR: Stanisz et al.","text":"","category":"section"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"Inversion-recovery method described by Stanisz et al. (2005). The following function takes qMT parameters as an input, simulates the signal, performs a mono-exponential T₁ fit as described in the publication, and returns the T₁ estimate. Sequence details are extracted from the publications and complemented with information kindly provided by the authors, as well as educated guesses where the corresponding information was not accessible. The latter two sources are indicated by comments in the functions.","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"function calculate_T1_IRStanisz(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    TRF_inv = 10e-6 # s; 10us - 20us according to private conversations\n    TRF_exc = TRF_inv # guessed, but has a negligible effect\n    TI = exp.(range(log(1e-3), log(32), 35)) # s\n    TD = similar(TI)\n    TD .= 20 # s\n\n    # simulate signal with an MT model\n    u_inv = RF_pulse_propagator(π / TRF_inv, B1, ω0, TRF_inv, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n    u_exc = RF_pulse_propagator(π / 2 / TRF_exc, B1, ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n\n    u_rti = [exp(hamiltonian_linear(0, B1, ω0, iTI - (TRF_inv + TRF_exc) / 2, m0s, R1f, R2f, Rx, R1s, 1)) for iTI ∈ TI]\n    u_rtd = [exp(hamiltonian_linear(0, B1, ω0, iTD - (TRF_inv + TRF_exc) / 2, m0s, R1f, R2f, Rx, R1s, 1)) for iTD ∈ TD]\n\n    s = similar(TI)\n    for i in eachindex(TI)\n        U = u_exc * u_rti[i] * u_inv * u_rtd[i]\n        s[i] = steady_state(U)[1]\n    end\n\n    # fit mono-expential model and return T₁ (in s)\n    model3(t, p) = p[1] .- p[2] .* exp.(-p[3] * t)\n    fit = curve_fit(model3, TI, s, [1, 2, 0.8])\n    return 1 / fit.param[end]\nend\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"We add the T₁ estimate from Stanisz et al. (2005), the function, and some auxiliary data to the above-initialized vectors:","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"push!(T1_literature, 1.084) # ± 0.045s in WM\npush!(T1_functions, calculate_T1_IRStanisz)\npush!(seq_name, \"IR Stanisz et al.\")\npush!(seq_type, :IR)\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/#IR:-Stikhov-et-al.","page":"T₁-mapping methods","title":"IR: Stikhov et al.","text":"","category":"section"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"Inversion-recovery method described by Stikhov et al. (2015).","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"function calculate_T1_IRStikhov(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    nLobes = 3 # confirmed by authors\n    TRF_exc = 3.072e-3 # s; confirmed by authors\n    TRF_ref = 3e-3 # s; confirmed by authors\n    TI = [30e-3, 530e-3, 1.03, 1.53] # s\n    TR = 1.55 # s\n    TE = 11e-3 # s\n\n    # simulate signal with an MT model\n    # excitation block\n    u_exc = RF_pulse_propagator(sinc_pulse(-π / 2, TRF_exc; nLobes=nLobes), B1, ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, T2s, MT_model; spoiler=true)\n    u_ref = RF_pulse_propagator(gauss_pulse(π, TRF_ref), B1, ω0, TRF_ref, m0s, R1f, R2f, Rx, R1s, T2s, MT_model; spoiler=false)\n    u_te2 = exp(hamiltonian_linear(0, B1, ω0, (TE - TRF_exc - TRF_ref) / 2, m0s, R1f, R2f, Rx, R1s, 1))\n    u_exc = u_ref * u_te2 * u_exc\n\n    # adiabatic inversion pulse confirmed by the authors\n    ω1, _, φ, TRF_inv = sech_inversion_pulse() # 360 deg, defined by the integral over the RF's real part.\n    u_inv = RF_pulse_propagator(ω1, B1, φ, TRF_inv, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n\n    # relaxation blocks\n    u_rti = [exp(hamiltonian_linear(0, B1, ω0, iTI - (TRF_inv + TRF_exc) / 2, m0s, R1f, R2f, Rx, R1s, 1)) for iTI ∈ TI]\n    u_rtd = [exp(hamiltonian_linear(0, B1, ω0, TR - iTI - (TRF_inv + TRF_ref + TE) / 2, m0s, R1f, R2f, Rx, R1s, 1)) for iTI ∈ TI]\n\n    s = similar(TI)\n    for i in eachindex(TI)\n        U = u_exc * u_sp * u_rti[i] * u_sp * u_inv * u_sp * u_rtd[i] * u_sp\n        s[i] = steady_state(U)[1]\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    model3(t, p) = p[1] .- p[2] .* exp.(-p[3] * t)\n    fit = curve_fit(model3, TI, s, [1, 2, 0.8])\n    return 1 / fit.param[end]\nend\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"push!(T1_literature, 850e-3) # s; peak of histogram\npush!(T1_functions, calculate_T1_IRStikhov)\npush!(seq_name, \"IR Stikhov et al.\")\npush!(seq_type, :IR)\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/#IR:-Preibisch-et-al.","page":"T₁-mapping methods","title":"IR: Preibisch et al.","text":"","category":"section"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"Inversion-recovery method described by Preibisch et al. (2009).","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"function calculate_T1_IRPreibisch(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    TI = [100, 200, 300, 400, 600, 800, 1000, 1200, 1600, 2000, 2600, 3200, 3800, 4400, 5000] .* 1e-3 # s\n    TD = 20 # s\n    TE = 27e-3 # s\n\n    # The adiabatic inversion pulse was identical to the one described in http://doi.org/10.1002/mrm.20552 (per private communications with Dr. Deichmann)\n    TRF_inv = 8.192e-3 # s\n    β = 4.5 # 1/s\n    μ = 5 # rad\n    ω₁ᵐᵃˣ=13.5*π/TRF_inv # rad/s\n    ω1_inv(t) = ω₁ᵐᵃˣ * sech(β * (2t / TRF_inv - 1)) # rad/s\n    φ_inv(t)  = μ * log(sech(β * (2t / TRF_inv - 1))) # rad\n\n    # simulate signal with an MT model\n    u_inv = RF_pulse_propagator(ω1_inv, B1, φ_inv, TRF_inv, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n\n    # The shape of the excitation pulse was kindly provided by Dr. Deichmann\n    TRF_exc = 2.5e-3 # s\n    _ω1_exc(t) = sinc(2 * abs(2t/TRF_exc-1)^0.88) * cos(π/2 * (2t/TRF_exc-1)) # rad/s\n    ω1_scale = π/2 / quadgk(_ω1_exc, 0, TRF_exc)[1]\n    ω1_exc(t) = _ω1_exc(t) * ω1_scale # rad/s\n    u_exc = RF_pulse_propagator(ω1_exc, B1, ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n    u_te = exp(hamiltonian_linear(0, B1, ω0, TE - TRF_exc / 2, m0s, R1f, R2f, Rx, R1s, 1))\n    u_exc = u_te * u_exc\n\n    # relaxation blocks\n    u_ti = [exp(hamiltonian_linear(0, B1, ω0, iTI - (TRF_inv + TRF_exc) / 2, m0s, R1f, R2f, Rx, R1s, 1)) for iTI ∈ TI]\n    u_td = exp(hamiltonian_linear(0, B1, ω0, TD - TRF_inv / 2 - TE, m0s, R1f, R2f, Rx, R1s, 1))\n\n    s = similar(TI)\n    for i in eachindex(TI)\n        U = u_exc * u_sp * u_ti[i] * u_sp * u_inv * u_sp * u_td * u_sp\n        s[i] = steady_state(U)[1]\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    # Fixed κ per private communications with Dr. Deichmann\n    κ = 1.964\n    model2(t, p) = p[1] .* (1 .- κ .* exp.(-p[2] * t))\n    fit = curve_fit(model2, TI, s, [1, 0.8])\n    return 1 / fit.param[end]\nend\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"push!(T1_literature, 881e-3) # s; median of WM ROIs; mean is 0.882 s\npush!(T1_functions, calculate_T1_IRPreibisch)\npush!(seq_name, \"IR Preibisch et al.\")\npush!(seq_type, :IR)\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/#IR:-Shin-et-al.","page":"T₁-mapping methods","title":"IR: Shin et al.","text":"","category":"section"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"Inversion-recovery method described by Shin et al. (2009).","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"function calculate_T1_IRShin(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    TI = exp.(range(log(34e-3), log(15), 10)) # s; Authors did not recall the TIs, but said they had at least 3–4 short times\n    TR = 30 # s\n    TRF_exc = 2.56e-3 # from Shin's memory\n\n    # simulate signal with an MT model\n    # EPI readout\n    u_exc = RF_pulse_propagator(sinc_pulse(16 / 180 * π, TRF_exc; nLobes=3), B1, ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n\n    # adiabatic inversion pulse\n    ω1, _, φ, TRF_inv = sech_inversion_pulse() # Shin confirmed \"standard Siemens\" adiabatic inversion pulse\n    u_inv = RF_pulse_propagator(ω1, B1, φ, TRF_inv, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n\n    # relaxation blocks\n    u_rti = [exp(hamiltonian_linear(0, B1, ω0, iTI - (TRF_inv + TRF_exc) / 2, m0s, R1f, R2f, Rx, R1s, 1)) for iTI ∈ TI]\n    u_rtd = [exp(hamiltonian_linear(0, B1, ω0, TR - iTI - (TRF_inv + TRF_exc) / 2, m0s, R1f, R2f, Rx, R1s, 1)) for iTI ∈ TI]\n\n    s = similar(TI)\n    for i in eachindex(TI)\n        U = u_exc * u_sp * u_rti[i] * u_sp * u_inv * u_sp * u_rtd[i] * u_sp\n        s[i] = steady_state(U)[1]\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    model3(t, p) = p[1] .- p[2] .* exp.(-p[3] * t)\n    fit = curve_fit(model3, TI, s, [1, 2, 0.8])\n    return 1 / fit.param[end]\nend\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"push!(T1_literature, 0.943) # ± 0.057 s in WM\npush!(T1_functions, calculate_T1_IRShin)\npush!(seq_name, \"IR Shin et al.\")\npush!(seq_type, :IR)\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/#LL:-Shin-et-al.","page":"T₁-mapping methods","title":"LL: Shin et al.","text":"","category":"section"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"Look-Locker method described by Shin et al. (2009).","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"function calculate_T1_LLShin(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    Nslices = 28 # (inner loop)\n    iSlice = Nslices - 18 # guessed from cf. Fig. 6 and 7, the author suggested that the slices were acquired in ascending order\n\n    TI1 = 12e-3 # s; the author suggested < 12ms\n    TD = 10 + TI1 # s; time duration of data acquisition per IR period\n    TR = 0.4 # s\n    TR_slice = TR / Nslices\n    TI = (0:TR:TD-TR)\n\n    α_exc = 16 * π / 180 # rad\n    TRF_exc = 2.56e-3 # s; from the authors' memory\n    nLobes = 3\n    Δω0 = (nLobes + 1) * 2π / TRF_exc # rad/s\n    ω0slice = ((1:Nslices) .- iSlice) * Δω0\n\n    # simulate signal with an MT model\n    ω1, _, φ, TRF_inv = sech_inversion_pulse() # Shin confirmed \"standard Siemens\" adiabatic inversion pulse\n    u_inv = RF_pulse_propagator(ω1, B1, φ, TRF_inv, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n\n    u_exc = Vector{Matrix{Float64}}(undef, length(ω0slice))\n    Threads.@threads for is ∈ eachindex(ω0slice)\n        if is == iSlice\n            u_exc[is] = RF_pulse_propagator(sinc_pulse(α_exc, TRF_exc; nLobes=nLobes), B1, ω0slice[is] + ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n        else # use Graham's model for off-resonant pulses for speed\n            u_exc[is] = exp(hamiltonian_linear(0, B1, ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, 1))\n            u_exc[is][5, 5] *= exp(-π * quadgk(t -> sinc_pulse(α_exc, TRF_exc; nLobes=nLobes)(t)^2, 0, TRF_exc)[1] * MRIgeneralizedBloch.lineshape_superlorentzian(ω0slice[is] + ω0, T2s))\n        end\n    end\n\n    U = exp(hamiltonian_linear(0, B1, ω0, TI1 - TRF_inv / 2 - TRF_exc / 2, m0s, R1f, R2f, Rx, R1s, 1))\n    for _ ∈ TI, is ∈ eachindex(ω0slice)\n        U = u_exc[is] * u_sp * U\n        U = exp(hamiltonian_linear(0, B1, -ω0slice[is] + ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, 1)) * U # rewind phase\n        U = exp(hamiltonian_linear(0, B1, ω0, TR_slice - 2TRF_exc, m0s, R1f, R2f, Rx, R1s, 1)) * U\n    end\n    U = u_sp * u_inv * u_sp * U\n    m = steady_state(U)\n\n    s = similar(TI)\n    m = exp(hamiltonian_linear(0, B1, ω0, TI1 - TRF_inv / 2 - TRF_exc / 2, m0s, R1f, R2f, Rx, R1s, 1)) * m\n    for iTI ∈ eachindex(s), is ∈ eachindex(ω0slice)\n        m = u_exc[is] * u_sp * m\n        m = exp(hamiltonian_linear(0, B1, -ω0slice[is] + ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, 1)) * m # rewind phase\n        m = exp(hamiltonian_linear(0, B1, ω0, TR_slice - 2TRF_exc, m0s, R1f, R2f, Rx, R1s, 1)) * m\n        if is == iSlice\n            s[iTI] = m[1]\n        end\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    model3(t, p) = p[1] .- p[2] .* exp.(-p[3] * t)\n    fit = curve_fit(model3, TI, s, [1, 2, 0.8])\n    R1a_est = fit.param[end] + log(cos(α_exc)) / TR\n    return 1 / R1a_est\nend\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"push!(T1_literature, 0.964) # ± 116s in WM\npush!(T1_functions, calculate_T1_LLShin)\npush!(seq_name, \"LL Shin et al.\")\npush!(seq_type, :LL)\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/#IR:-Lu-et-al.","page":"T₁-mapping methods","title":"IR: Lu et al.","text":"","category":"section"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"Inversion-recovery method described by Lu et al. (2005).","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"function calculate_T1_IRLu(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    TRF_exc = 1e-3 # s; 0.5-2 ms according to P Zijl\n    TI = [180, 630, 1170, 1830, 2610, 3450, 4320, 5220, 6120, 7010] .* 1e-3 # s\n    TD = 8 # s\n    TE = 42e-3 # s\n\n    # simulate signal with an MT model\n    # excitation block; GRASE RO w/ TSE factor 4\n    u_exc = RF_pulse_propagator(sinc_pulse(π / 2, TRF_exc; nLobes=3), B1, ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, T2s, MT_model; spoiler=true)\n    u_ref = RF_pulse_propagator(sinc_pulse(π, TRF_exc; nLobes=3), B1, ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, T2s, MT_model; spoiler=false)\n    u_te1 = exp(hamiltonian_linear(0, B1, ω0, TE / 4 - TRF_exc, m0s, R1f, R2f, Rx, R1s, 1))\n    u_te234 = exp(hamiltonian_linear(0, B1, ω0, TE / 4 - TRF_exc / 2, m0s, R1f, R2f, Rx, R1s, 1))\n    u_exc = u_te234 * u_ref * u_te234^2 * u_ref * u_te1 * u_exc # 2 refocusing pulses before the RO\n\n    # adiabatic inversion pulse\n    ω1, _, φ, TRF_inv = sech_inversion_pulse(ω₁ᵐᵃˣ=4965.910769033364 * 750 / 360) # nom. α = 750deg according to P. Zijl\n    u_inv = RF_pulse_propagator(ω1, B1, φ, TRF_inv, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n\n    # relaxation blocks\n    u_ti = [exp(hamiltonian_linear(0, B1, ω0, iTI - (TRF_inv + TRF_exc) / 2, m0s, R1f, R2f, Rx, R1s, 1)) for iTI ∈ TI]\n\n    u_et = u_te234 * u_ref * u_te234^2 * u_ref * u_te234 # 2 refocusing pulses after the RO\n    u_td = [exp(hamiltonian_linear(0, B1, ω0, TD - 2TE - TRF_inv / 2, m0s, R1f, R2f, Rx, R1s, 1)) * u_et for _ ∈ TI]\n\n    s = similar(TI)\n    for i in eachindex(TI)\n        U = u_exc * u_sp * u_ti[i] * u_sp * u_inv * u_sp * u_td[i] * u_sp\n        s[i] = abs(steady_state(U)[1])\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    model3(t, p) = abs.(p[1] .* (1 .- p[2] .* exp.(-p[3] * t)))\n    fit = curve_fit(model3, TI, s, [1, 2, 0.8])\n    return 1 / fit.param[end]\nend\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"push!(T1_literature, 0.735) # s; median of WM ROIs; reported T1 = (748 ± 64)ms in the splenium of the CC and (699 ± 38)ms in WM\npush!(T1_functions, calculate_T1_IRLu)\npush!(seq_name, \"IR Lu et al.\")\npush!(seq_type, :IR)\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/#LL:-Stikhov-et-al.","page":"T₁-mapping methods","title":"LL: Stikhov et al.","text":"","category":"section"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"Look-Locker method described by Stikhov et al. (2015).","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"function calculate_T1_LLStikhov(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    TR = 1.55 # s\n    TI = [30e-3, 530e-3, 1.03, 1.53] # s\n    TRF_inv = 720e-6 # s; for 180deg pulse, 90deg pulse are half as long\n\n    # simulate signal with an MT model\n    u_90  = MRIgeneralizedBloch.xs_destructor(nothing) * RF_pulse_propagator(π / TRF_inv, B1, ω0, TRF_inv / 2, m0s, R1f, R2f, Rx, R1s, T2s, MT_model, spoiler=true)\n    u_inv = MRIgeneralizedBloch.xs_destructor(nothing) * RF_pulse_propagator(π / TRF_inv, B1, ω0, TRF_inv,     m0s, R1f, R2f, Rx, R1s, T2s, MT_model, spoiler=false)\n    u_m90 = MRIgeneralizedBloch.xs_destructor(nothing) * RF_pulse_propagator(π / TRF_inv, B1, ω0, TRF_inv / 2, m0s, R1f, R2f, Rx, R1s, T2s, MT_model, spoiler=false)\n    u_rotp = MRIgeneralizedBloch.z_rotation_propagator(π/2, nothing)\n    u_rotm = MRIgeneralizedBloch.z_rotation_propagator(-π/2, nothing)\n    u_inv = u_rotp * u_m90 * u_rotm * u_inv * u_rotp * u_90  # 90-180-90 pattern confirmed by authors\n    TRF_inv *= 2\n\n    α_exc = 5 * π / 180 # rad\n    nLobes = 7 # confirmed by authors\n    TRF_exc = 2.56e-3 # s; confirmed by authors\n    ω1 = sinc_pulse(α_exc, TRF_exc; nLobes=nLobes)\n    u_exc = RF_pulse_propagator(ω1, B1, ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n\n    dTI = TI .- [0; TI[1:end-1]]\n    dTI[1] -= (TRF_inv + TRF_exc) / 2\n    dTI[2:end] .-= TRF_exc\n\n    u_ir = [exp(hamiltonian_linear(0, B1, ω0, dTI[i], m0s, R1f, R2f, Rx, R1s, 1)) for i in eachindex(dTI)]\n    u_fp = exp(hamiltonian_linear(0, B1, ω0, TR - TI[end] - (TRF_inv + TRF_exc) / 2, m0s, R1f, R2f, Rx, R1s, 1))\n\n    U = I\n    for i in eachindex(TI)\n        U = u_exc * u_ir[i] * U\n    end\n    U = u_inv * u_fp * U\n    m = steady_state(U)\n\n    s = similar(TI)\n    for i in eachindex(TI)\n        m = u_exc * u_ir[i] * m\n        s[i] = m[1]\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    # model as provided by Stikhov et al. in a private communication\n    function model_num(t, p)\n        any(t .!= TI) ? error() : nothing\n\n        cα_exc = cos(α_exc)\n        TI1 = TI[1]\n        TI2 = TI[2] - TI[1]\n        Nll = length(TI)\n\n        tr = TR - TI1 - (Nll - 1) .* TI2 # time between last exc and inv pulse\n\n\n        E1 = exp.(-TI1 ./ p[2])\n        E2 = exp.(-TI2 ./ p[2])\n        Er = exp.(-tr ./ p[2])\n\n        F = (1 - E2) ./ (1 - cα_exc .* E2)\n        Qnom = -F .* cα_exc .* Er .* E1 .* (1 .- (cα_exc .* E2) .^ (Nll - 1)) .- E1 .* (1 .- Er) .- E1 .+ 1\n        Qdenom = 1 .+ cα_exc .* Er .* E1 .* (cα_exc .* E2) .^ (Nll - 1)\n        Q = Qnom / Qdenom\n\n        Mz = zeros(Nll)\n        Msig = zeros(Nll)\n\n        for ii = 1:Nll\n            Mz[ii] = F .+ (cα_exc .* E2) .^ (ii - 1) .* (Q - F)\n            Msig[ii] = p[1] .* sin(α_exc) .* Mz[ii]\n        end\n        return Msig\n    end\n\n    fit = curve_fit(model_num, TI, s, [1.0, 1.0])\n    return fit.param[end]\nend\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"push!(T1_literature, 0.750) # s; peak of histogram; cf. https://doi.org/10.1016/j.mri.2016.08.021\npush!(T1_functions, calculate_T1_LLStikhov)\npush!(seq_name, \"LL Stikhov et al.\")\npush!(seq_type, :LL)\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/#vFA:-Stikhov-et-al.","page":"T₁-mapping methods","title":"vFA: Stikhov et al.","text":"","category":"section"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"Variable flip-angle method described by Stikhov et al. (2015).","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"function calculate_T1_vFAStikhov(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    α = [3, 10, 20, 30] * π / 180 # rad\n    TR = 15e-3 # s\n    TRF = 2e-3 # s; confirmed by authors\n    nLobes = 9 # confirmed by authors\n\n    # simulate signal with an MT model\n    s = similar(α)\n    for i in eachindex(α)\n        u_exc = RF_pulse_propagator(sinc_pulse(α[i], TRF; nLobes=nLobes), B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n        u_fp = exp(hamiltonian_linear(0, B1, ω0, TR - TRF, m0s, R1f, R2f, Rx, R1s, 1))\n\n        U = u_exc * u_sp * u_fp\n        s[i] = steady_state(U)[1]\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    f = lm(@formula(Y ~ X), DataFrame(X=s ./ tan.(α), Y=s ./ sin.(α)))\n    T1_est = -TR / log(f.model.pp.beta0[2])\n    return T1_est\nend\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"push!(T1_literature, 1.07) # s; peak of histogram (cf. https://doi.org/10.1016/j.mri.2016.08.021)\npush!(T1_functions, calculate_T1_vFAStikhov)\npush!(seq_name, \"vFA Stikhov et al.\")\npush!(seq_type, :vFA)\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/#vFA:-Cheng-et-al.","page":"T₁-mapping methods","title":"vFA: Cheng et al.","text":"","category":"section"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"Variable flip-angle method described by Cheng et al. (2006).","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"function calculate_T1_vFACheng(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    α = [2, 9, 19] * π / 180 # rad\n    TR = 6.1e-3 # s\n    TRF = 1e-3 # s; guessed\n    nLobes = 3 # guessed\n\n    # simulate signal with an MT model\n    s = similar(α)\n    for i in eachindex(α)\n        u_exc = RF_pulse_propagator(sinc_pulse(α[i], TRF; nLobes=nLobes), B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n        u_fp = exp(hamiltonian_linear(0, B1, ω0, TR - TRF, m0s, R1f, R2f, Rx, R1s, 1))\n\n        U = u_exc * u_sp * u_fp\n        s[i] = steady_state(U)[1]\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    f = lm(@formula(Y ~ X), DataFrame(X=s ./ tan.(α), Y=s ./ sin.(α)))\n    T1_est = -TR / log(f.model.pp.beta0[2])\n    return T1_est\nend\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"push!(T1_literature, 1.0855) # s; mean of two volunteers\npush!(T1_functions, calculate_T1_vFACheng)\npush!(seq_name, \"vFA Cheng et al.\")\npush!(seq_type, :vFA)\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/#vFA:-Chavez-and-Stanisz","page":"T₁-mapping methods","title":"vFA: Chavez & Stanisz","text":"","category":"section"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"Variable flip-angle method described by Chavez & Stanisz (2012).","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"function calculate_T1_vFA_Chavez(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    α = [1, 40, 130, 150] * π / 180 # rad\n    TR = 40e-3 # s\n\n    # simulate signal with an MT model\n    s = similar(α)\n    for i in eachindex(α)\n        TRF = α[i] / (π/0.5e-3) # s; guessed, incl. constant ω1 / variable TRF\n        u_exc = RF_pulse_propagator(α[i]/TRF, B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, T2s, MT_model) # rect. pulse shape guessed because \"slab-select gradient [...] [is] turned off\"\n        u_fp = exp(hamiltonian_linear(0, B1, ω0, TR - TRF, m0s, R1f, R2f, Rx, R1s, 1))\n\n        U = u_exc * u_sp * u_fp\n        s[i] = steady_state(U)[1]\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    # NLLS fit as described in the paper\n    function vFA_signal(α, p)\n        S0, B1, T1 = p\n        E1 = exp(-TR / T1)\n        return S0 .* sin.(B1 .* α) .* (1 - E1) ./ (1 .- cos.(B1 .* α) .* E1)\n    end\n\n    fit_vFA = curve_fit(vFA_signal, α, s, ones(3))\n    return fit_vFA.param[end]\nend\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"push!(T1_literature, 1.044) # s; median of corpus callosum ROIs\npush!(T1_functions, calculate_T1_vFA_Chavez)\npush!(seq_name, \"vFA Chavez & Stanisz\")\npush!(seq_type, :vFA)\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/#vFA:-Preibisch-et-al.","page":"T₁-mapping methods","title":"vFA: Preibisch et al.","text":"","category":"section"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"Variable flip-angle method described by Preibisch et al. (2009).","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"function calculate_T1_vFAPreibisch(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    α = [4, 18] * π / 180 # rad\n    TR = 7.6e-3 # s\n    TRF = 0.2e-3 # s; confirmed by Dr. Deichmann\n\n    # simulate signal with an MT model\n    s = similar(α)\n    for i in eachindex(α)\n        u_exc = RF_pulse_propagator(α[i] / TRF, B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n        u_fp = exp(hamiltonian_linear(0, B1, ω0, (TR - TRF) / 2, m0s, R1f, R2f, Rx, R1s, 1))\n\n        U = u_fp * u_exc * u_fp\n        s[i] = steady_state(U)[1]\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    f = lm(@formula(Y ~ X), DataFrame(X=s .* α, Y=s ./ α))\n    T1_est = -2 * TR * f.model.pp.beta0[2]\n    return T1_est\nend\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"push!(T1_literature, 0.940) # s; median of ROIs; mean = 0.951s\npush!(T1_functions, calculate_T1_vFAPreibisch)\npush!(seq_name, \"vFA Preibisch et al.\")\npush!(seq_type, :vFA)\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/#vFA-Hybrid-FLASH-EPI:-Preibisch-et-al.","page":"T₁-mapping methods","title":"vFA - Hybrid FLASH-EPI: Preibisch et al.","text":"","category":"section"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"Variable flip-angle method with a Hybrid FLASH-EPI readout described by Preibisch et al. (2009).","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"function calculate_T1_vFAPreibisch_HYB(m0s, R1f, R2f, Rx, R1s, T2s, α, TR)\n    # define sequence parameters\n    TRF = 0.2e-3 # s; confirmed by Dr. Deichmann\n\n    # simulate signal with an MT model\n    s = similar(α)\n    for i in eachindex(α)\n        u_exc = RF_pulse_propagator(α[i] / TRF, B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n        u_fp = exp(hamiltonian_linear(0, B1, ω0, (TR - TRF) / 2, m0s, R1f, R2f, Rx, R1s, 1))\n        U = u_fp * u_exc * u_fp\n        s[i] = steady_state(U)[1]\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    SL = (s[2]/sin(α[2]) - s[1]/sin(α[1])) / (s[2]/tan(α[2]) - s[1]/tan(α[1]))\n    T1_est = -TR / log(SL)\n    return T1_est\nend\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"For this sequence, we simulate three different settings with different flip angles and repetition times:","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"push!(T1_literature, 0.955) # s\npush!(T1_functions, (m0s, R1f, R2f, Rx, R1s, T2s) -> calculate_T1_vFAPreibisch_HYB(m0s, R1f, R2f, Rx, R1s, T2s, [4, 22] .* π ./ 180, 12.5e-3))\npush!(seq_name, \"vFA HYB12.5ms Preibisch et al.\")\npush!(seq_type, :vFA)\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"push!(T1_literature, 0.949) # s\npush!(T1_functions, (m0s, R1f, R2f, Rx, R1s, T2s) -> calculate_T1_vFAPreibisch_HYB(m0s, R1f, R2f, Rx, R1s, T2s, [4, 24] .* π ./ 180, 15.2e-3))\npush!(seq_name, \"vFA HYB15.2ms Preibisch et al.\")\npush!(seq_type, :vFA)\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"push!(T1_literature, 0.959) # s\npush!(T1_functions, (m0s, R1f, R2f, Rx, R1s, T2s) -> calculate_T1_vFAPreibisch_HYB(m0s, R1f, R2f, Rx, R1s, T2s, [4, 25] .* π ./ 180, 15.9e-3))\npush!(seq_name, \"vFA HYB15.9ms Preibisch et al.\")\npush!(seq_type, :vFA)\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/#vFA:-Teixeira-et-al.","page":"T₁-mapping methods","title":"vFA: Teixeira et al.","text":"","category":"section"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"Variable flip-angle method described by Teixeira et al. (2019).","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"function calculate_T1_vFATeixeira(m0s, R1f, R2f, Rx, R1s, T2s, ω1rms)\n    # define sequence parameters\n    α = [6, 12, 18] * π / 180 # rad – provided Dr. Teixeira\n    TR = 15e-3 # s; provided by Dr. Teixeira for Fig. 7\n    TRF = 3e-3 # s; confirmed by Dr. Teixeira\n    ω0_CSMT = 6e3 * 2π # 6kHz – confirmed by Dr. Teixeira\n\n    # simulate signal with an MT model\n    s = similar(α)\n    Threads.@threads for i in eachindex(α)\n        u_exc = RF_pulse_propagator(CSMT_pulse(α[i], TRF, TR, ω1rms, ω0=ω0_CSMT), B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n        u_fp = exp(hamiltonian_linear(0, B1, ω0, (TR - TRF) / 2, m0s, R1f, R2f, Rx, R1s, 1))\n\n        U = u_fp * u_exc * u_fp\n        s[i] = steady_state(U)[1]\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    f = lm(@formula(Y ~ X), DataFrame(X=s ./ tan.(α), Y=s ./ sin.(α))) # DESPOT1 confirmed by Dr. Teixeira\n    T1_est = -TR / log(f.model.pp.beta0[2])\n    return T1_est\nend\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"For this sequence, we simulate five different B₁-RMS values:","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"push!(T1_literature, 0.825) # s; read from Fig. 7\npush!(T1_functions, (m0s, R1f, R2f, Rx, R1s, T2s) -> calculate_T1_vFATeixeira(m0s, R1f, R2f, Rx, R1s, T2s, 0.4e-6 * 267.522e6)) # rad/s\npush!(seq_name, \"vFA CSMT w/ B1rms = 0.4uT Teixeira et al.\")\npush!(seq_type, :vFA)\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"push!(T1_literature, 0.775) # s; read from Fig. 7\npush!(T1_functions, (m0s, R1f, R2f, Rx, R1s, T2s) -> calculate_T1_vFATeixeira(m0s, R1f, R2f, Rx, R1s, T2s, 0.8e-6 * 267.522e6)) # rad/s\npush!(seq_name, \"vFA CSMT w/ B1rms = 0.8uT Teixeira et al.\")\npush!(seq_type, :vFA)\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"push!(T1_literature, 0.73) # s; read from Fig. 7\npush!(T1_functions, (m0s, R1f, R2f, Rx, R1s, T2s) -> calculate_T1_vFATeixeira(m0s, R1f, R2f, Rx, R1s, T2s, 1.2e-6 * 267.522e6)) # rad/s\npush!(seq_name, \"vFA CSMT w/ B1rms = 1.2uT Teixeira et al.\")\npush!(seq_type, :vFA)\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"push!(T1_literature, 0.68) # s; read from Fig. 7\npush!(T1_functions, (m0s, R1f, R2f, Rx, R1s, T2s) -> calculate_T1_vFATeixeira(m0s, R1f, R2f, Rx, R1s, T2s, 1.6e-6 * 267.522e6)) # rad/s\npush!(seq_name, \"vFA CSMT w/ B1rms = 1.6uT Teixeira et al.\")\npush!(seq_type, :vFA)\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"push!(T1_literature, 0.64) # s; read from Fig. 7\npush!(T1_functions, (m0s, R1f, R2f, Rx, R1s, T2s) -> calculate_T1_vFATeixeira(m0s, R1f, R2f, Rx, R1s, T2s, 2e-6 * 267.522e6)) # rad/s\npush!(seq_name, \"vFA CSMT w/ B1rms = 2uT Teixeira et al.\")\npush!(seq_type, :vFA)\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/#MPRAGE:-Marques-et-al.","page":"T₁-mapping methods","title":"MP₂RAGE: Marques et al.","text":"","category":"section"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"MP₂RAGE method described by Marques et al. (2010).","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"function calculate_T1_MP2RAGE(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    α = [4, 5] .* π / 180 # rad\n    TRl = 6.75 # s\n    TR_FLASH = 7.9e-3 # s\n    TI = [0.8, 3.2] # s\n    Nz = 160 ÷ 3\n\n    # simulate signal with an MT model\n    # adiabatic inversion pulse\n    ω1, _, φ, TRF_inv = sechn_inversion_pulse(n=8, ω₁ᵐᵃˣ=25e-6 * 267.522e6) # HS8 pulse confirmed by Dr. Marques; amplitude chosen close to the max. of a typical 3T system\n    u_inv = u_sp * RF_pulse_propagator(ω1, B1, φ, TRF_inv, m0s, R1f, R2f, Rx, R1s, T2s, MT_model) * u_sp\n\n    ta = TI[1] - Nz / 2 * TR_FLASH - TRF_inv / 2\n    tb = TI[2] - TI[1] - Nz * TR_FLASH\n    tc = TRl - TI[2] - Nz / 2 * TR_FLASH - TRF_inv / 2\n\n    u_ta = exp(hamiltonian_linear(0, B1, ω0, ta, m0s, R1f, R2f, Rx, R1s, 1))\n    u_tb = exp(hamiltonian_linear(0, B1, ω0, tb, m0s, R1f, R2f, Rx, R1s, 1))\n    u_tc = exp(hamiltonian_linear(0, B1, ω0, tc, m0s, R1f, R2f, Rx, R1s, 1))\n\n    # excitation blocks\n    # binomial water excitation pulses; 1-2-1 pulse scheme confirmed for the Siemens product sequence; not specifically for the prototype.\n    TRF_bin = 0.2e-3 # s; guessed, but has little influence the estimated T1\n    τ = 1 / (2 * 430) - TRF_bin # s; fat-water shift = 440Hz\n    TRF_exc = 2τ + 3TRF_bin # s\n\n    u_1 = RF_pulse_propagator(α[1] / 4 / TRF_bin, B1, ω0, TRF_bin, m0s, R1f, R2f, Rx, R1s, T2s, MT_model, spoiler=false)\n    u_2 = RF_pulse_propagator(2α[1] / 4 / TRF_bin, B1, ω0, TRF_bin, m0s, R1f, R2f, Rx, R1s, T2s, MT_model, spoiler=false)\n    u_t = exp(hamiltonian_linear(0, B1, ω0, τ, m0s, R1f, R2f, Rx, R1s, 1))\n    u_exc1 = u_1 * u_t * u_2 * u_t * u_1\n\n    u_1 = RF_pulse_propagator(α[2] / 4 / TRF_bin, B1, ω0, TRF_bin, m0s, R1f, R2f, Rx, R1s, T2s, MT_model, spoiler=false)\n    u_2 = RF_pulse_propagator(2α[2] / 4 / TRF_bin, B1, ω0, TRF_bin, m0s, R1f, R2f, Rx, R1s, T2s, MT_model, spoiler=false)\n    u_t = exp(hamiltonian_linear(0, B1, ω0, τ, m0s, R1f, R2f, Rx, R1s, 1))\n    u_exc2 = u_1 * u_t * u_2 * u_t * u_1\n\n    u_te = exp(hamiltonian_linear(0, B1, ω0, (TR_FLASH - TRF_exc) / 2, m0s, R1f, R2f, Rx, R1s, 1))\n    u_exc1 = u_te * u_exc1 * u_sp * u_te\n    u_exc2 = u_te * u_exc2 * u_sp * u_te\n\n    # Propagation matrix in temporal order:\n    # U = u_tc * u_exc2^Nz * u_tb * u_exc1^Nz * u_ta * u_inv\n    U1 = u_exc1^(Nz / 2) * u_ta * u_inv * u_tc * u_exc2^Nz * u_tb * u_exc1^(Nz / 2)\n    U2 = u_exc2^(Nz / 2) * u_tb * u_exc1^Nz * u_ta * u_inv * u_tc * u_exc2^(Nz / 2)\n\n    s1 = steady_state(U1)[1]\n    s2 = steady_state(U2)[1]\n    sm = s1' * s2 / (abs(s1)^2 + abs(s2)^2)\n\n    # fit mono-expential model and return T1 (in s)\n    function MP2RAGE_signal(T1)\n        eff_inv = 0.96 # from paper\n\n        E1 = exp(-TR_FLASH / T1)\n        EA = exp(-ta / T1)\n        EB = exp(-tb / T1)\n        EC = exp(-tc / T1)\n\n        mzss = (((((1 - EA) * (cos(α[1]) * E1)^Nz + (1 - E1) * (1 - (cos(α[1]) * E1)^Nz) / (1 - cos(α[1]) * E1)) * EB + (1 - EB)) * (cos(α[2]) * E1)^Nz + (1 - E1) * (1 - (cos(α[2]) * E1)^Nz) / (1 - cos(α[2]) * E1)) * EC + (1 - EC)) / (1 + eff_inv * (cos(α[1]) * cos(α[2]))^Nz * exp(-TRl / T1))\n\n        s1 = sin(α[1]) * ((-eff_inv * mzss * EA + (1 - EA)) * (cos(α[1]) * E1)^(Nz / 2 - 1) + (1 - E1) * (1 - (cos(α[1]) * E1)^(Nz / 2 - 1)) / (1 - cos(α[1]) * E1))\n        s2 = sin(α[2]) * ((mzss - (1 - EC)) / (EC * (cos(α[2]) * E1)^(Nz / 2)) - (1 - E1) * ((cos(α[2]) * E1)^(-Nz / 2) - 1) / (1 - cos(α[2]) * E1))\n\n        sm = s1' * s2 / (abs(s1)^2 + abs(s2)^2)\n        return sm\n    end\n\n    fit = curve_fit((_, T1) -> MP2RAGE_signal.(T1), [1], [sm], [0.5])\n    return fit.param[1]\nend\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"push!(T1_literature, 0.81) # ± 0.03 s\npush!(T1_functions, calculate_T1_MP2RAGE)\npush!(seq_name, \"MP2RAGE Marques et al.\")\npush!(seq_type, :MP2RAGE)\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/#MP-RAGE:-Wright-et-al.","page":"T₁-mapping methods","title":"MP-RAGE: Wright et al.","text":"","category":"section"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"MP-RAGE method described by Wright et al. (2008).","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"function calculate_T1_MPRAGE_Wright(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    TRl = 5 # s\n    TR_FLASH = 11e-3 # s\n    TE = 6.7e-3 # s\n    TI = [160, 190, 285, 441, 680, 1050, 1619, 2100] .* 1e-3 # s\n    Nz = 256\n\n    # simulate signal with an MT model\n    # adiabatic inversion pulse\n    TRF_inv = 13.5e-3 # s; from the paper\n    β = 600 # 1/s; picked for 10kHz bandwidth\n    μ = 5  # rad – 50 rad would match 10 kHz bandwidth, 5 rad chosen for computation speed (makes little difference)\n    ω₁ᵐᵃˣ = 4 * sqrt(μ) * β # rad/s; compromise of appromximating 1.25 >> 1 and keeping B1max in limits\n    ω1, _, φ, TRF_inv = sech_inversion_pulse(TRF=TRF_inv, β=β, μ=μ, ω₁ᵐᵃˣ=ω₁ᵐᵃˣ) # standard Philips inverson pulse, likely hyperbolic secant, as confirmed by Dr. Gowland\n    u_inv = u_sp * RF_pulse_propagator(ω1, B1, φ, TRF_inv, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n\n    # excitation blocks\n    α = (8/20:8/20:8) .* π / 180 # rad – pattern confirmed by Dr. Gowland\n    TRF_exc = 0.67e-3 # s\n    nLobes = 7 # sinc pulses confirmed by Dr. Gowland; number of lobes guessed guessed to approximate the 11.9kHz bandwidth discussed in the paper\n\n    u_exc = [RF_pulse_propagator(sinc_pulse(α[i], TRF_exc; nLobes=nLobes), B1, ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, T2s, MT_model) for i in eachindex(α)]\n    u_te = exp(hamiltonian_linear(0, B1, ω0, TE - TRF_exc / 2, m0s, R1f, R2f, Rx, R1s, 1))\n    u_tr = exp(hamiltonian_linear(0, B1, ω0, TR_FLASH - TE - TRF_exc / 2, m0s, R1f, R2f, Rx, R1s, 1))\n    u_exc = [u_te * u_exc[i] * u_tr for i in eachindex(u_exc)]\n    u_exc_ramp = prod(u_exc[end:-1:1])\n\n    s = similar(TI)\n    for iTI in eachindex(TI)\n        ti = TI[iTI] - TRF_inv / 2 - (TR_FLASH - TE) - length(α) * TR_FLASH\n        tc = TRl - TI[iTI] - Nz * TR_FLASH - TRF_inv / 2 - TE + length(α) * TR_FLASH\n\n        u_ti = exp(hamiltonian_linear(0, B1, ω0, ti, m0s, R1f, R2f, Rx, R1s, 1))\n        u_tc = exp(hamiltonian_linear(0, B1, ω0, tc, m0s, R1f, R2f, Rx, R1s, 1))\n\n        # Propagation matrix in temporal order: U = u_tc * u_exc20^(Nz-20) * ... u_exc2 * u_exc1 * u_ti * u_inv\n        U = u_exc_ramp * u_ti * u_inv * u_tc * u_exc[end]^(Nz - length(α))\n        s[iTI] = steady_state(U)[1] # extract x-magnetization\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    function MPRAGE_mz(TI, p)\n        T1, M0, α_inv = p\n\n        function hamiltonian_T1(T, R1)\n            H = @SMatrix [\n                -R1  R1;\n                  0   0]\n            return H * T\n        end\n        function pulse_propgator(α)\n            U = @SMatrix [\n                cos(α)  0;\n                     0  1]\n            return U\n        end\n        function steady_state_2D(U)\n            Q = U - @SMatrix [1 0; 0 0]\n            m = Q \\ @SVector [0,1]\n            return m\n        end\n\n        s = similar(TI)\n        for iTI in eachindex(TI)\n            ti = TI[iTI] - length(α) * TR_FLASH\n            tc = TRl - TI[iTI] - Nz * TR_FLASH + length(α) * TR_FLASH\n\n            u_ti = exp(hamiltonian_T1(ti, 1/T1))\n            u_tr = exp(hamiltonian_T1(TR_FLASH, 1/T1))\n            u_tc = exp(hamiltonian_T1(tc, 1/T1))\n\n            # Propagation matrix in temporal order: U = u_tc * u_exc20^(Nz-20) * ... u_exc2 * u_exc1 * u_ta * u_inv\n            U = u_tr * pulse_propgator(α[end])\n            for i in (length(α)-1):-1:1\n                U = U * u_tr * pulse_propgator(α[i])\n            end\n            U = U * u_ti * pulse_propgator(α_inv) * u_tc * (u_tr * pulse_propgator(α[end]))^(Nz - length(α))\n            s[iTI] = M0 * steady_state_2D(U)[1] # extract z-magnetization\n        end\n        return s\n    end\n\n    fit = curve_fit(MPRAGE_mz, TI, s, [1, sin(α[end]), 0.9π])\n    return fit.param[1]\nend\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"push!(T1_literature, 0.84) # s\npush!(T1_functions, calculate_T1_MPRAGE_Wright)\npush!(seq_name, \"MPRAGE Wright et al.\")\npush!(seq_type, :MP2RAGE)\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/#Adiabatic-IR:-Wright-et-al.","page":"T₁-mapping methods","title":"Adiabatic IR: Wright et al.","text":"","category":"section"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"Inversion-recovery method with adiabatic inversion pulse described by Wright et al. (2008).","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"function calculate_T1_IR_EPI_Wright(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    TI = [120, 200, 400, 600, 900, 1500, 2100, 3000, 4000] .* 1e-3 # s\n    TR = 35 # s\n    TE = 45e-3 # s\n    TRF_exc = 7.7e-3 # s\n    nLobes = 1 # chose to match 395 Hz bandwidth\n\n    # simulate signal with an MT model\n    # adiabatic inversion pulse\n    TRF_inv = 17.51e-3 # s\n    β = 500 # 1/s; chosen to fit 713Hz bandwidth\n    μ = 5   # rad – chosen to fit 713Hz bandwidth\n    ω₁ᵐᵃˣ = 2 * sqrt(μ) * β # rad/s; compromise of appromximating 2 >> 1 and keeping B1max in limits\n    ω1, _, φ, TRF_inv = sech_inversion_pulse(TRF=TRF_inv, β=β, μ=μ, ω₁ᵐᵃˣ=ω₁ᵐᵃˣ)\n    u_inv = u_sp * RF_pulse_propagator(ω1, B1, φ, TRF_inv, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n\n    # relaxation blocks\n    u_ti = [exp(hamiltonian_linear(0, B1, ω0, iTI - TRF_inv/2 - TRF_exc/2, m0s, R1f, R2f, Rx, R1s, 1)) for iTI ∈ TI]\n    u_td = [exp(hamiltonian_linear(0, B1, ω0,  TR - TRF_inv/2 - iTI - TE , m0s, R1f, R2f, Rx, R1s, 1)) for iTI ∈ TI]\n\n    # excitation block\n    u_exc = RF_pulse_propagator(sinc_pulse(π / 2, TRF_exc; nLobes=nLobes), B1, ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n    u_te = exp(hamiltonian_linear(0, B1, ω0, TE - TRF_exc / 2, m0s, R1f, R2f, Rx, R1s, 1))\n    u_exc = u_te * u_exc\n\n    s = similar(TI)\n    for i in eachindex(TI)\n        U = u_exc * u_sp * u_ti[i] * u_sp * u_inv * u_sp * u_td[i] * u_sp\n        s[i] = steady_state(U)[1]\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    model3(t, p) = p[1] .* (1 .- p[2] .* exp.(-p[3] * t)) # p[2] = (1 - cos(α))\n    fit = curve_fit(model3, TI, s, [1, 2, 0.8])\n    return 1 / fit.param[end]\nend\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"push!(T1_literature, 0.9) # s; read from Fig. 5\npush!(T1_functions, calculate_T1_IR_EPI_Wright)\npush!(seq_name, \"IR EPI Wright et al.\")\npush!(seq_type, :IR)\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/#Adiabatic-IR:-Reynolds-et-al.","page":"T₁-mapping methods","title":"Adiabatic IR: Reynolds et al.","text":"","category":"section"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"Inversion-recovery method with adiabatic inversion pulse described by Reynolds et al. (2023).","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"function calculate_T1_IRReynolds_adiabatic(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    TRF_exc = 1e-3 # s; guessed\n    nLobes = 3 # s; guessed\n    TI = [5.5, 10.2, 35.8, 66.9, 125, 234, 598, 818, 1118, 1529, 3910, 5348] .* 1e-3 # s; measured from end to beginning of respective pulse (confirmed by Dr. Reynolds)\n    TD = 5 # s\n    TE = 10e-3 # s; guessed, but has negligible impact\n\n    # simulate signal with an MT model\n    # adiabatic inversion pulse\n    ω1, _, φ, TRF_inv = sech_inversion_pulse(TRF=10e-3, ω₁ᵐᵃˣ=13.5e-6 * 267.522e6, μ=1.8380981750265004, β=730)\n    u_inv = RF_pulse_propagator(ω1, B1, φ, TRF_inv, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n\n    # relaxation blocks\n    u_ti = [exp(hamiltonian_linear(0, B1, ω0, iTI, m0s, R1f, R2f, Rx, R1s, 1)) for iTI ∈ TI]\n    u_td = exp(hamiltonian_linear(0, B1, ω0, TD - TE, m0s, R1f, R2f, Rx, R1s, 1))\n\n    # excitation block\n    u_exc = RF_pulse_propagator(sinc_pulse(π / 2, TRF_exc; nLobes=nLobes), B1, ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n    u_te = exp(hamiltonian_linear(0, B1, ω0, TE - TRF_exc / 2, m0s, R1f, R2f, Rx, R1s, 1))\n    u_exc = u_te * u_exc\n\n    s = similar(TI)\n    for i in eachindex(TI)\n        U = u_exc * u_sp * u_ti[i] * u_sp * u_inv * u_sp * u_td * u_sp\n        s[i] = steady_state(U)[1]\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    model3(t, p) = p[1] .* (1 .- p[2] .* exp.(-p[3] * t)) # confirmed by Dr. Reynolds\n    fit = curve_fit(model3, TI, s, [1, 2, 0.8])\n    return 1 / fit.param[end]\nend\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"push!(T1_literature, 0.905) # s\npush!(T1_functions, calculate_T1_IRReynolds_adiabatic)\npush!(seq_name, \"IR ad. Reynolds et al.\")\npush!(seq_type, :IR)\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/#Sinc-IR:-Reynolds-et-al.","page":"T₁-mapping methods","title":"Sinc IR: Reynolds et al.","text":"","category":"section"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"Inversion-recovery method with a sinc inversion pulse described by Reynolds et al. (2023).","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"function calculate_T1_IRReynolds_sinc(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    TRF_exc = 1e-3 # s; guessed\n    nLobes_exc = 3 # s; guessed\n    TI = [5.5, 10.2, 35.8, 66.9, 125, 234, 598, 818, 1118, 1529, 3910, 5348] .* 1e-3 # s; measured from end to beginning of respective pulse (confirmed by Dr. Reynolds)\n    TD = 5 # s\n    TE = 10e-3 # s; guessed, but has negligible impact\n\n    # simulate signal with an MT model\n    # excitation block\n    u_exc = RF_pulse_propagator(sinc_pulse(π / 2, TRF_exc; nLobes=nLobes_exc), B1, ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n    u_te = exp(hamiltonian_linear(0, B1, ω0, TE - TRF_exc / 2, m0s, R1f, R2f, Rx, R1s, 1))\n    u_exc = u_te * u_exc\n\n    # sinc inversion pulse\n    TRF_inv = 3e-3 # s\n    nLobes_inv = 3\n    u_inv = RF_pulse_propagator(sinc_pulse(π, TRF_inv; nLobes=nLobes_inv), B1, ω0, TRF_inv, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n\n    # relaxation blocks\n    u_ti = [exp(hamiltonian_linear(0, B1, ω0, iTI, m0s, R1f, R2f, Rx, R1s, 1)) for iTI ∈ TI]\n    u_td = exp(hamiltonian_linear(0, B1, ω0, TD - TE, m0s, R1f, R2f, Rx, R1s, 1))\n\n    s = similar(TI)\n    for i in eachindex(TI)\n        U = u_exc * u_sp * u_ti[i] * u_sp * u_inv * u_sp * u_td * u_sp\n        s[i] = steady_state(U)[1]\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    model3(t, p) = p[1] .* (1 .- p[2] .* exp.(-p[3] * t)) # confirmed by Rd. Reynolds\n    fit = curve_fit(model3, TI, s, [1, 2, 0.8])\n    return 1 / fit.param[end]\nend\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"push!(T1_literature, 0.861) # s\npush!(T1_functions, calculate_T1_IRReynolds_sinc)\npush!(seq_name, \"IR sinc Reynolds et al.\")\npush!(seq_type, :IR)\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/#SR:-Reynolds-et-al.","page":"T₁-mapping methods","title":"SR: Reynolds et al.","text":"","category":"section"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"Saturation recovery method described by Reynolds et al. (2023).","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"function calculate_T1_SRReynolds(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    TRF_exc = 1e-3 # s; guessed, but has negligible impact\n    nLobes_exc = 5 # guessed, but has negligible impact\n    TI = [5.5, 10.2, 35.8, 66.9, 125, 234, 598, 818, 1118, 1529, 3910, 5348] .* 1e-3 # s; measured from end to beginning of respective pulse (confirmed by Dr. Reynolds)\n    TD = 5 # s\n    TE = 10e-3 # s; guessed, but has negligible impact\n\n    # simulate signal with an MT model\n    # saturation pulse\n    TRF_sat = 0.5 # s\n    ω1 = 10 * 2π # rad/s\n    u_sat = RF_pulse_propagator(ω1, B1, ω0, TRF_sat, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n\n    # relaxation blocks\n    u_ti = [exp(hamiltonian_linear(0, B1, ω0, iTI, m0s, R1f, R2f, Rx, R1s, 1)) for iTI ∈ TI]\n    u_td = exp(hamiltonian_linear(0, B1, ω0, TD - TE, m0s, R1f, R2f, Rx, R1s, 1))\n\n    # excitation block\n    u_exc = RF_pulse_propagator(sinc_pulse(π / 2, TRF_exc; nLobes=nLobes_exc), B1, ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n    u_te = exp(hamiltonian_linear(0, B1, ω0, TE - TRF_exc / 2, m0s, R1f, R2f, Rx, R1s, 1))\n    u_exc = u_te * u_exc\n\n    s = similar(TI)\n    for i in eachindex(TI)\n        U = u_exc * u_ti[i] * u_sp * u_sat * u_td * u_sp\n        s[i] = steady_state(U)[1]\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    model3(t, p) = p[1] .* (1 .- p[2] .* exp.(-p[3] * t)) # confirmed by Dr. Reynolds\n    fit = curve_fit(model3, TI, s, [1, 2, 0.8])\n    return 1 / fit.param[end]\nend\nnothing #hide","category":"page"},{"location":"build_literate/T1_mapping_methods/","page":"T₁-mapping methods","title":"T₁-mapping methods","text":"push!(T1_literature, 1.013) # s\npush!(T1_functions, calculate_T1_SRReynolds)\npush!(seq_name, \"SR Reynolds et al.\")\npush!(seq_type, :SR)\nnothing #hide","category":"page"},{"location":"build_literate/Derivatives_HelperFunctions/#Helper-functions-for-the-sensitivity-analysis","page":"Helper functions for the sensitivity analysis","title":"Helper functions for the sensitivity analysis","text":"","category":"section"},{"location":"build_literate/Derivatives_HelperFunctions/#Load-additional-packages","page":"Helper functions for the sensitivity analysis","title":"Load additional packages","text":"","category":"section"},{"location":"build_literate/Derivatives_HelperFunctions/","page":"Helper functions for the sensitivity analysis","title":"Helper functions for the sensitivity analysis","text":"using FiniteDifferences\nusing DataFrames\nusing CategoricalArrays\nusing CSV\nusing MixedModels\nusing StatsPlots\nusing Printf\nusing Combinatorics","category":"page"},{"location":"build_literate/Derivatives_HelperFunctions/#Analyze-fixed-models-with-Shapley-regression","page":"Helper functions for the sensitivity analysis","title":"Analyze fixed models with Shapley regression","text":"","category":"section"},{"location":"build_literate/Derivatives_HelperFunctions/","page":"Helper functions for the sensitivity analysis","title":"Helper functions for the sensitivity analysis","text":"function shapley_regression(df, lhs, p)\n    Δr² = similar(p, Float64)\n    Δr² .= 0\n\n    for ipick ∈ eachindex(p)\n        p_pick = p[ipick]\n        p_rest = filter(x -> x != p_pick, p)\n        r_terms = term(1) + (term(1) | term(:seq_type)) + (term(1) | term(:seq_name)) + (term(1) | term(:ROI))\n\n        for nterms = 0:length(p_rest)\n            weight = 1 / length(combinations(p_rest, nterms)) / (length(p_rest) + 1)\n            for combination ∈ combinations(p_rest, nterms)\n                rhs = combination == Symbol[] ? r_terms : sum(t -> term(t), combination) + r_terms\n                r²_rest = _r2(df, term(lhs), rhs)\n\n                rhs += term(p_pick)\n                r²_pick = _r2(df, term(lhs), rhs)\n\n                Δr²[ipick] += weight * (r²_pick - r²_rest)\n            end\n        end\n    end\n    return Δr²\nend\n\nfunction _r2(df, lhs, rhs)\n    model = fit(MixedModel, lhs ~ rhs, df)\n    fixedeffects = Symbol.(rhs[collect(typeof.(rhs) .== Term)])\n\n    σ²_fixed = isempty(fixedeffects) ? 0 : var(sum(param -> model.βs[param] .* df[!, param], fixedeffects); corrected=false)\n    σ²_ROI = model.σs[:ROI][1]^2\n    σ²_seqname = model.σs[:seq_name][1]^2\n    σ²_seqtype = model.σs[:seq_type][1]^2\n    σ²_ϵ = model.σ^2\n    σ²_all = σ²_fixed + σ²_ROI + σ²_seqtype + σ²_seqname + σ²_ϵ\n    r² = σ²_fixed / σ²_all\n    return r²\nend\nnothing #hide","category":"page"},{"location":"build_literate/Derivatives_HelperFunctions/#Helper-function:","page":"Helper functions for the sensitivity analysis","title":"Helper function:","text":"","category":"section"},{"location":"build_literate/Derivatives_HelperFunctions/","page":"Helper functions for the sensitivity analysis","title":"Helper functions for the sensitivity analysis","text":"function get_main_path()\n    path_parts = splitpath(pwd())\n    i_docs = findfirst(==(\"docs\"), path_parts)\n    main_path = i_docs === nothing ? pwd() : joinpath(path_parts[1:i_docs-1]...)\n    return main_path\nend\nnothing #hide","category":"page"},{"location":"#Magnetization-transfer-explains-most-of-the-T-variability-in-the-MRI-literature","page":"Home","title":"Magnetization transfer explains most of the T₁ variability in the MRI literature","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The code in the first section reproduces all results in the paper Magnetization transfer explains most of the T₁ variability in the MRI literature. The code is written in the open-source language Julia and is structured as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"T₁-mapping methods: This script contains functions to simulate the MR signal of each T₁-mapping method and fit a mono-exponential T₁ to the simulated data.\nGlobal fit: This script performs the fits of the quantitative magnetization transfer parameters to the variable T₁ estimates.\nHelper functions: This script contains implementations of RF pulses and some helper functions, which are less relevant for understanding the simulations. This script also loads all required packages.","category":"page"},{"location":"#Sensitivity-of-literature-T-mapping-methods-to-the-underlying-magnetization-transfer-parameters","page":"Home","title":"Sensitivity of literature T₁ mapping methods to the underlying magnetization transfer parameters","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The code in the second section reproduces all results in the follow-up paper Sensitivity of literature T₁ mapping methods to the underlying magnetization transfer parameters. The code is also written in the open-source language Julia and is structured as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Sensitivity analysis: This script calculates the derivatives, analyzes, and plots them.\nHelper functions for the sensitivity analysis: This script contains functions for the calculation of the coefficient of determination R². This script also loads all required packages.","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Global-fit","page":"Global fit","title":"Global fit","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"First, we load the required packages and include some Helper functions","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"include(\"helper_functions.jl\")\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"load all T₁-mapping methods:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"include(\"T1_mapping_methods.jl\")\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"and initialize the plot:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"p = plot([0, 2], [0, 2], xlabel=\"simulated T1 (s)\", ylabel=\"literature T1 (s)\", legend=:topleft, label=:none, xlim=(0.5, 1.1), ylim=(0.5, 1.1))\nmarker_list = [(seq_type_i == :IR) ? (:circle) : ((seq_type_i == :LL) ? (:cross) : ((seq_type_i == :vFA) ? (:diamond) : ((seq_type_i == :SR) ? (:dtriangle) : (:x)))) for seq_type_i in seq_type]\n\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Mono-exponential-model","page":"Global fit","title":"Mono-exponential model","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"We simulate the mono-exponential model as an MT model with a vanishing semi-solid spin pool. In this case, the underlying MT model is irrelevant, and we choose Graham's model for speed purposes:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"MT_model = Graham()\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"The following parameters are hard-coded, except for R1f, which serves as an initialization for the global fit.","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"m0s = 0\nR1f = 1 / 1.084  # 1/s\nR1s = R1f        # 1/s\nR2f = 1 / 0.0769 # 1/s\nT2s = 0\nRx = 0           # 1/s\nω0 = 0\nB1 = 1\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"We define a model for the global fit. It takes the global set of parameters p as an input and returns a vector of T₁ estimates that correspond to the T₁ mapping methods described by the vector T1_functions","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"function model(iseq, p)\n    R1f = p[1]\n    T1 = similar(iseq, Float64)\n    Threads.@threads for i in eachindex(iseq)\n        T1[i] = T1_functions[iseq[i]](m0s, R1f, R2f, Rx, R1s, T2s)\n    end\n    return T1\nend\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"Perform the fit and calculate the simulated T₁:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"fit_mono = curve_fit(model, 1:length(T1_literature), T1_literature, [R1f], x_tol=1e-3)\nT1_simulated = model(1:length(T1_literature), fit_mono.param)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"For this model, the single fitted global parameter is:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"T1f = 1 / fit_mono.param[1] # s","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"The following plot visualizes the quality of the fit and replicates Fig. 1 in the manuscript:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"scatter!(p, T1_simulated, T1_literature, label=\"mono-exponential model\", markershape=marker_list, hover=seq_name)\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria","page":"Global fit","title":"Akaike (AIC) and Bayesian (BIC) information criteria","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"The information criteria depend on the number of measurements:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"n = length(T1_literature)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"the number of parameters:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"k = length(fit_mono.param)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"and the squared sum of the residuals:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"RSS = norm(fit_mono.resid)^2","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"As the AIC and BIC are only informative in the difference between two models, we use the mono-exponential model as the reference:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"AIC_mono = n * log(RSS / n) + 2k","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"BIC_mono = n * log(RSS / n) + k * log(n)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"In this case, ΔAIC is by definition zero:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"ΔAIC = n * log(RSS / n) + 2k - AIC_mono","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"as is ΔBIC:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"ΔBIC = n * log(RSS / n) + k * log(n) - BIC_mono","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Graham's-MT-model-(unconstrained-Rˢ)","page":"Global fit","title":"Graham's MT model (unconstrained R₁ˢ)","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"MT_model = Graham()\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"The following parameters are hard-coded, except for m0s, R1f, and R1s, which serve as an initialization for the global fit.","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"m0s = 0.25\nR1f = 1 / 1.84   # 1/s\nR1s = 1 / 0.34   # 1/s\nR2f = 1 / 0.0769 # 1/s\nT2s = 12.5e-6    # s\nRx = 13.6        # 1/s\nω0 = 0\nB1 = 1\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"We define a model for the global fit. It takes the global set of parameters p as an input and returns a vector of T₁ estimates that correspond to the T₁ mapping methods described by the vector T1_functions","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"function model(iseq, p)\n    m0s, R1f, R1s = p\n    T1 = similar(iseq, Float64)\n    Threads.@threads for i in eachindex(iseq)\n        T1[i] = T1_functions[iseq[i]](m0s, R1f, R2f, Rx, R1s, T2s)\n    end\n    return T1\nend\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"Perform the fit and calculate the simulated T₁:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"fit_Graham = curve_fit(model, 1:length(T1_literature), T1_literature, [m0s, R1f, R1s], x_tol=1e-3)\nT1_simulated = model(1:length(T1_literature), fit_Graham.param)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"For this model, the fitted global set of parameters is:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"m0s = fit_Graham.param[1]","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"T1f = 1 / fit_Graham.param[2] # s","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"T1s = 1 / fit_Graham.param[3] # s","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"The following plot visualizes the quality of the fit and replicates Fig. 1 in the manuscript:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"scatter!(p, T1_simulated, T1_literature, label=\"Graham's model (unconstrained R₁ˢ)\", markershape=marker_list, hover=seq_name)\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"Note that clicking on a legend entry removes the fit from the plot. A double click on an entry selects only this particular fit.","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-2","page":"Global fit","title":"Akaike (AIC) and Bayesian (BIC) information criteria","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"The information criteria depend on the number of measurements n, the number of parameters k, and the squared sum of the residuals RSS:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"n = length(T1_literature)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"k = length(fit_Graham.param)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"RSS = norm(fit_Graham.resid)^2","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"With this information, we can calculate the AIC difference to the mono-exponential model:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"ΔAIC = n * log(RSS / n) + 2k - AIC_mono","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"and similarly for the BIC:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"ΔBIC = n * log(RSS / n) + k * log(n) - BIC_mono","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Sled's-MT-model-(unconstrained-Rˢ)","page":"Global fit","title":"Sled's MT model (unconstrained R₁ˢ)","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"MT_model = Sled()\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"The following parameters are hard-coded, except for m0s, R1f, and R1s, which serve as an initialization for the global fit.","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"m0s = 0.25\nR1f = 1 / 1.84   # 1/s\nR1s = 1 / 0.34   # 1/s\nR2f = 1 / 0.0769 # 1/s\nT2s = 12.5e-6    # s\nRx = 13.6        # 1/s\nω0 = 0\nB1 = 1\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"We define a model for the global fit. It takes the global set of parameters p as an input and returns a vector of T₁ estimates that correspond to the T₁ mapping methods described by the vector T1_functions","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"function model(iseq, p)\n    m0s, R1f, R1s = p\n    T1 = similar(iseq, Float64)\n    Threads.@threads for i in eachindex(iseq)\n        T1[i] = T1_functions[iseq[i]](m0s, R1f, R2f, Rx, R1s, T2s)\n    end\n    return T1\nend\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"Perform the fit and calculate the simulated T₁:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"fit_Sled = curve_fit(model, 1:length(T1_literature), T1_literature, [m0s, R1f, R1s], x_tol=1e-3)\nT1_simulated = model(1:length(T1_literature), fit_Sled.param)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"For this model, the fitted global set of parameters is:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"m0s = fit_Sled.param[1]","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"T1f = 1 / fit_Sled.param[2] # s","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"T1s = 1 / fit_Sled.param[3] # s","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"The following plot visualizes the quality of the fit and replicates Fig. 1 in the manuscript:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"scatter!(p, T1_simulated, T1_literature, label=\"Sled's model (unconstrained R₁ˢ)\", markershape=marker_list, hover=seq_name)\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"Note that clicking on a legend entry removes the fit from the plot. A double click on an entry selects only this particular fit.","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-3","page":"Global fit","title":"Akaike (AIC) and Bayesian (BIC) information criteria","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"The information criteria depend on the number of measurements n, the number of parameters k, and the squared sum of the residuals RSS:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"n = length(T1_literature)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"k = length(fit_Sled.param)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"RSS = norm(fit_Sled.resid)^2","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"With this information, we can calculate the AIC difference to the mono-exponential model:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"ΔAIC = n * log(RSS / n) + 2k - AIC_mono","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"and similarly for the BIC:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"ΔBIC = n * log(RSS / n) + k * log(n) - BIC_mono","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Generalized-Bloch-model-(Rˢ-Rᶠ)","page":"Global fit","title":"Generalized Bloch model (R₁ˢ = R₁ᶠ)","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"MT_model = gBloch()\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"The following parameters are hard-coded, except for m0s and R1f, which serve as an initialization for the global fit.","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"m0s = 0.139\nR1f = 1 / 1.084  # 1/s\nR1s = 1          # 1/s\nR2f = 1 / 0.0769 # 1/s\nT2s = 12.5e-6    # s\nRx = 23          # 1/s\nω0 = 0\nB1 = 1\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"We define a model for the global fit. It takes the global set of parameters p as an input and returns a vector of T₁ estimates that correspond to the T₁ mapping methods described by the vector T1_functions","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"function model(iseq, p)\n    m0s, R1f = p\n    R1s = R1f\n    T1 = similar(iseq, Float64)\n    Threads.@threads for i in eachindex(iseq)\n        T1[i] = T1_functions[iseq[i]](m0s, R1f, R2f, Rx, R1s, T2s)\n    end\n    return T1\nend\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"Perform the fit and calculate the simulated T₁:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"fit_constr = curve_fit(model, 1:length(T1_literature), T1_literature, [m0s, R1f], x_tol=1e-3)\nT1_simulated = model(1:length(T1_literature), fit_constr.param)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"For this model, the fitted global set of parameters is:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"m0s = fit_constr.param[1]","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"T1f = 1 / fit_constr.param[2] # s","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"The following plot visualizes the quality of the fit and replicates Fig. 1 in the manuscript:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"scatter!(p, T1_simulated, T1_literature, label=\"generalized Bloch model (R₁ˢ = R₁ᶠ constraint)\", markershape=marker_list, hover=seq_name)\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"Note that clicking on a legend entry removes the fit from the plot. A double click on an entry selects only this particular fit.","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-4","page":"Global fit","title":"Akaike (AIC) and Bayesian (BIC) information criteria","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"The information criteria depend on the number of measurements n, the number of parameters k, and the squared sum of the residuals RSS:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"n = length(T1_literature)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"k = length(fit_constr.param)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"RSS = norm(fit_constr.resid)^2","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"With this information, we can calculate the AIC difference to the mono-exponential model:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"ΔAIC = n * log(RSS / n) + 2k - AIC_mono","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"and similarly for the BIC:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"ΔBIC = n * log(RSS / n) + k * log(n) - BIC_mono","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Generalized-Bloch-model-(unconstrained-Rˢ)","page":"Global fit","title":"Generalized Bloch model (unconstrained R₁ˢ)","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"MT_model = gBloch()\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"The following parameters are hard-coded, except for m0s, R1f, and R1s, which serve as an initialization for the global fit.","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"m0s = 0.25\nR1f = 1 / 1.84   # 1/s\nR1s = 1 / 0.34   # 1/s\nR2f = 1 / 0.0769 # 1/s\nT2s = 12.5e-6    # s\nRx = 13.6        # 1/s\nω0 = 0\nB1 = 1\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"We define a model for the global fit. It takes the global set of parameters p as an input and returns a vector of T₁ estimates that correspond to the T₁ mapping methods described by the vector T1_functions","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"function model(iseq, p)\n    m0s, R1f, R1s = p\n    T1 = similar(iseq, Float64)\n    Threads.@threads for i in eachindex(iseq)\n        T1[i] = T1_functions[iseq[i]](m0s, R1f, R2f, Rx, R1s, T2s)\n    end\n    return T1\nend\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"Perform the fit and calculate the simulated T₁:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"fit_uncon = curve_fit(model, 1:length(T1_literature), T1_literature, [m0s, R1f, R1s], x_tol=1e-3)\nT1_simulated = model(1:length(T1_literature), fit_uncon.param)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"For this model, the fitted global set of parameters is:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"m0s = fit_uncon.param[1]","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"T1f = 1 / fit_uncon.param[2] # s","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"T1s = 1 / fit_uncon.param[3] # s","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"The following plot visualizes the quality of the fit and replicates Fig. 1 in the manuscript:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"scatter!(p, T1_simulated, T1_literature, label=\"generalized Bloch model (unconstrained R₁ˢ)\", markershape=marker_list, hover=seq_name)\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"Note that clicking on a legend entry removes the fit from the plot. A double click on an entry selects only this particular fit.","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-5","page":"Global fit","title":"Akaike (AIC) and Bayesian (BIC) information criteria","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"The information criteria depend on the number of measurements n, the number of parameters k, and the squared sum of the residuals RSS:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"n = length(T1_literature)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"k = length(fit_uncon.param)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"RSS = norm(fit_uncon.resid)^2","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"With this information, we can calculate the AIC difference to the mono-exponential model:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"ΔAIC = n * log(RSS / n) + 2k - AIC_mono","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"and similarly for the BIC:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"ΔBIC = n * log(RSS / n) + k * log(n) - BIC_mono","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Data-analysis","page":"Global fit","title":"Data analysis","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"The span of T₁ estimates in the literature is","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"extrema(T1_literature)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"and the coefficient of variation is","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"variation(T1_literature)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Median-absolute-deviation","page":"Global fit","title":"Median absolute deviation","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"In the paper, the median absolute deviation from the mean value is used, as it is more robust to outliers compared to the mean absolute deviation or the standard deviation. Note, however, that the median absolute deviation of the mono-exponential fit is dominated by an outlier, artificially inflating the corresponding reduction.","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"A mono-exponential model explains the following fraction of the T₁ variability in the literature:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"1 - mad(fit_mono.resid; center=mean(fit_mono.resid)) / mad(T1_literature; center=mean(T1_literature))","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"Graham's spectral model without constraints on R₁ᶠ explains the following fraction of the T₁ variability in the literature:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"1 - mad(fit_Graham.resid; center=mean(fit_Graham.resid)) / mad(T1_literature; center=mean(T1_literature))","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"Sled's model without constraints on R₁ᶠ explains the following fraction of the T₁ variability in the literature:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"1 - mad(fit_Sled.resid; center=mean(fit_Sled.resid)) / mad(T1_literature; center=mean(T1_literature))","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"The generalized Bloch model constrained by R₁ˢ = R₁ᶠ explains the following fraction of the T₁ variability in the literature:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"1 - mad(fit_constr.resid; center=mean(fit_constr.resid)) / mad(T1_literature; center=mean(T1_literature))","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"The generalized Bloch model without constraints on R₁ᶠ explains the following fraction of the T₁ variability in the literature:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"1 - mad(fit_uncon.resid; center=mean(fit_uncon.resid)) / mad(T1_literature; center=mean(T1_literature))","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Mean-absolute-deviation","page":"Global fit","title":"Mean absolute deviation","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"For comparison, the mean absolute deviation is analyzed: A mono-exponential model explains the following fraction of the T₁ variability in the literature:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"1 - mean(abs.(fit_mono.resid .- mean(fit_mono.resid))) / mean(abs.(T1_literature .- mean(T1_literature)))","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"Graham's spectral model without constraints on R₁ᶠ explains the following fraction of the T₁ variability in the literature:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"1 - mean(abs.(fit_Graham.resid .- mean(fit_Graham.resid))) / mean(abs.(T1_literature .- mean(T1_literature)))","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"Sled's model without constraints on R₁ᶠ explains the following fraction of the T₁ variability in the literature:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"1 - mean(abs.(fit_Sled.resid .- mean(fit_Sled.resid))) / mean(abs.(T1_literature .- mean(T1_literature)))","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"The generalized Bloch model constrained by R₁ˢ = R₁ᶠ explains the following fraction of the T₁ variability in the literature:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"1 - mean(abs.(fit_constr.resid .- mean(fit_constr.resid))) / mean(abs.(T1_literature .- mean(T1_literature)))","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"The generalized Bloch model without constraints on R₁ᶠ explains the following fraction of the T₁ variability in the literature:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"1 - mean(abs.(fit_uncon.resid .- mean(fit_uncon.resid))) / mean(abs.(T1_literature .- mean(T1_literature)))","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Standard-deviation","page":"Global fit","title":"Standard deviation","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"For comparison, the standard deviation is analyzed: A mono-exponential model explains the following fraction of the T₁ variability in the literature:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"1 - std(fit_mono.resid) / std(T1_literature)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"Graham's spectral model without constraints on R₁ᶠ explains the following fraction of the T₁ variability in the literature:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"1 - std(fit_Graham.resid) / std(T1_literature)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"Sled's spectral model without constraints on R₁ᶠ explains the following fraction of the T₁ variability in the literature:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"1 - std(fit_Sled.resid) / std(T1_literature)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"The generalized Bloch model constrained by R₁ˢ = R₁ᶠ explains the following fraction of the T₁ variability in the literature:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"1 - std(fit_constr.resid) / std(T1_literature)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"The generalized Bloch model without constraints on R₁ᶠ explains the following fraction of the T₁ variability in the literature:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"Global fit","title":"Global fit","text":"1 - std(fit_uncon.resid) / std(T1_literature)","category":"page"}]
}
