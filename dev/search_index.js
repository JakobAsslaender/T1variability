var documenterSearchIndex = {"docs":
[{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"EditURL = \"../../../helper_functions.jl\"","category":"page"},{"location":"build_literate/helper_functions/#Helper-functions","page":"Helper functions","title":"Helper functions","text":"","category":"section"},{"location":"build_literate/helper_functions/#Load-packages","page":"Helper functions","title":"Load packages","text":"","category":"section"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"using MRIgeneralizedBloch\nusing StaticArrays\nusing Statistics\nusing QuadGK\nusing DifferentialEquations\nusing SpecialFunctions\nusing LinearAlgebra\nusing DataFrames\nusing GLM\nusing StatsBase\nusing LsqFit\nusing ApproxFun\nusing Plots\nplotlyjs(bg=RGBA(31 / 255, 36 / 255, 36 / 255, 1.0), ticks=:native, size=(600, 600))\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/#Define-MT-models","page":"Helper functions","title":"Define MT models","text":"","category":"section"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"These structs are used to identify the MT model with Julia's multiple dispatch mechanism","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"struct gBloch end\nstruct Graham end\nstruct Sled end\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/#Spoiler-propagator","page":"Helper functions","title":"Spoiler propagator","text":"","category":"section"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"This matrix implements \"perfect\" RF spoiling that destroys all transversal magnetization.","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"u_sp = @SMatrix [\n    0 0 0 0 0 0\n    0 0 0 0 0 0\n    0 0 1 0 0 0\n    0 0 0 0 0 0\n    0 0 0 0 1 0\n    0 0 0 0 0 1]\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/#Steady-state","page":"Helper functions","title":"Steady state","text":"","category":"section"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"The input U of this function is a propagator that describes the spin evolution during an RF pulse sequence. It uses linear algebra to calculate the steady state magnetization m resulting from repeated execution of the pulse sequence described by U.","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"function steady_state(U)\n    U0 = @SMatrix [\n        1 0 0 0 0 0;\n        0 1 0 0 0 0;\n        0 0 1 0 0 0;\n        0 0 0 1 0 0;\n        0 0 0 0 1 0;\n        0 0 0 0 0 0]\n    Q = U - U0\n    m = Q \\ @SVector [0,0,0,0,0,1]\n    return m\nend\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/#Pre-calculate-the-linearization-of-the-generalized-Bloch-model","page":"Helper functions","title":"Pre-calculate the linearization of the generalized Bloch model","text":"","category":"section"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"Refer to the documentation of the generalized Bloch package for details.","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"const G = interpolate_greens_function(greens_superlorentzian, 0, 1000)\nR2sl = precompute_R2sl(TRF_max=5e-3, ω1_max=π / 500e-6)[1]\nR2sl_short = precompute_R2sl(TRF_min=10e-6, TRF_max=20e-6, ω1_max=π / 10e-6)[1]\nnoth\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/#RF-pulse-propagators","page":"Helper functions","title":"RF pulse propagators","text":"","category":"section"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"function RF_pulse_propagator(ω1::Number, B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, T2s, model::gBloch; spoiler=true)\n    if TRF >= 10e-6 && TRF <= 20e-6\n        R2s = R2sl_short(TRF, abs(ω1 * TRF), B1, T2s)\n        U = exp(hamiltonian_linear(ω1, B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, R2s))\n        U = spoiler ? U * u_sp : U\n    elseif TRF >= 100e-6 && TRF <= 5e-3\n        R2s = R2sl(TRF, abs(ω1 * TRF), B1, T2s)\n        U = exp(hamiltonian_linear(ω1, B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, R2s))\n        U = spoiler ? U * u_sp : U\n    else\n        U = RF_pulse_propagator(_ -> ω1, B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, T2s, model; spoiler=spoiler)\n    end\n    return U\nend\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"function RF_pulse_propagator(ω1::Function, B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, T2s, model::gBloch; spoiler=true)\n    U = zeros(6, 6)\n    Ui = @view U[[1:3; 5:6], [1:3; 5:6]]\n\n    i_in = spoiler ? (3:5) : (1:5) # if a spoiler precedes the pulse, only the z magnetization is non-zero\n    Threads.@threads for i ∈ i_in\n        m0 = zeros(5)\n        m0[i] = 1\n        mfun(p, t; idxs=nothing) = typeof(idxs) <: Number ? m0[idxs] : m0\n        Ui[1:5, i] = solve(DDEProblem(apply_hamiltonian_gbloch!, m0, mfun, (0, TRF), (ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, G)), reltol=1e-6, MethodOfSteps(RK4()))[end]\n    end\n    return U\nend\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"function RF_pulse_propagator(ω1, B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, T2s, model::Sled; spoiler=true)\n    m0 = zeros(5)\n    U = zeros(6, 6)\n    Ui = @view U[[1:3; 5:6], [1:3; 5:6]]\n\n    i_in = spoiler ? (3:5) : (1:5) # if a spoiler precedes the pulse, only the z magnetization is non-zero\n    for i ∈ i_in\n        m0 .= 0\n        m0[i] = 1\n        mfun(p, t; idxs=nothing) = typeof(idxs) <: Number ? m0[idxs] : m0\n        Ui[1:5, i] = solve(ODEProblem(apply_hamiltonian_sled!, m0, (0, TRF), (ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, G)), reltol=1e-6)[end]\n    end\n    return U\nend\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"function RF_pulse_propagator(ω1::Real, B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, T2s, model::Graham; spoiler=true)\n    m0 = zeros(5)\n    U = zeros(6, 6)\n    Ui = @view U[[1:3; 5:6], [1:3; 5:6]]\n\n    i_in = spoiler ? (3:5) : (1:5) # if a spoiler precedes the pulse, only the z magnetization is non-zero\n    for i ∈ i_in\n        m0 .= 0\n        m0[i] = 1\n        mfun(p, t; idxs=nothing) = typeof(idxs) <: Number ? m0[idxs] : m0\n        Ui[1:5, i] = solve(ODEProblem(apply_hamiltonian_graham_superlorentzian!, m0, (0, TRF), (ω1, B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, T2s)), reltol=1e-6)[end]\n    end\n    return U\nend\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"function RF_pulse_propagator(ω1, B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, T2s, model::Graham; spoiler=true)\n    Rrf = graham_saturation_rate_spectral_fast(ω1, B1, ω0, TRF, T2s)\n\n    m0 = zeros(5)\n    U = zeros(6, 6)\n    Ui = @view U[[1:3; 5:6], [1:3; 5:6]]\n\n    i_in = spoiler ? (3:5) : (1:5) # if a spoiler precedes the pulse, only the z magnetization is non-zero\n    for i ∈ i_in\n        m0 .= 0\n        m0[i] = 1\n        mfun(p, t; idxs=nothing) = typeof(idxs) <: Number ? m0[idxs] : m0\n        Ui[1:5, i] = solve(ODEProblem(apply_hamiltonian_linear!, m0, (0, TRF), (ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, Rrf)), reltol=1e-6)[end]\n    end\n    return U\nend\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/#Helper-functions-for-Graham's-spectral-model","page":"Helper functions","title":"Helper functions for Graham's spectral model","text":"","category":"section"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"The following code saves and reuses the saturation rate Rrf of an RF pulse to speed up the simulation.","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"struct Rrf_Atom\n    ω1_sqrtTRF::Float64\n    ω1_TRFo2::Float64\n    ω1_TRFmsqrtTRF::Float64\n    B1::Float64\n    ω0::Float64\n    TRF::Float64\n    T2s::Float64\n    Rrf::Float64\nend\nRrf_Dict = Rrf_Atom[]\nfunction graham_saturation_rate_spectral_fast(ω1, B1, ω0, TRF, T2s)\n    T2s == 0 && return 1 # for mono-exponential model\n\n    d_ω0 = typeof(ω0) <: Function ? ω0(sqrt(TRF)) : ω0 # just used for comparison\n\n    for x ∈ Rrf_Dict\n        if ω1(sqrt(TRF)) == x.ω1_sqrtTRF && ω1(TRF/2) == x.ω1_TRFo2 && ω1(TRF-sqrt(TRF)) == x.ω1_TRFmsqrtTRF && B1 == x.B1 && d_ω0 == x.ω0 && TRF == x.TRF && T2s == x.T2s\n            return x.Rrf\n        end\n    end\n\n    Rrf = graham_saturation_rate_spectral(ω0_int -> lineshape_superlorentzian(ω0_int, T2s), t -> ω1(t)*B1, TRF, ω0)\n    push!(Rrf_Dict, Rrf_Atom(ω1(sqrt(TRF)), ω1(TRF/2), ω1(TRF-sqrt(TRF)), B1, d_ω0, TRF, T2s, Rrf))\n    return Rrf\nend\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/#RF-pulse-definitions","page":"Helper functions","title":"RF pulse definitions","text":"","category":"section"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"function sinc_pulse(α, TRF; nLobes=3)\n    nLobes % 2 != 1 ? error() : nothing\n    x = (nLobes - 1) / 2 + 1\n    ω1(t) = sinc((2t / TRF - 1) * x) * α * x * π / (sinint(x * π) * TRF)\nend\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"function hanning_pulse(α, TRF)\n    ω1(t) = α * cos(π * t / TRF - π / 2)^2 * 2 / TRF\nend\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"function gauss_pulse(α, TRF; shape_alpha=2.5)\n    y(t) = exp(-((2 * t / TRF - 1) * shape_alpha)^2 / 2)\n    ω1(t) = α * (y(t) - y(0)) / (sqrt(π/2) * TRF * erf(shape_alpha/sqrt(2)) / shape_alpha - y(0)*TRF)\nend\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"function CSMT_pulse(α, TRF, TR, ω1rms; ω0=12000π)\n    ω1_0 = gauss_pulse(α, TRF; shape_alpha=2.5) # shape & shape_alpha confirmed by Dr. Teixeira\n    ω1ms_0 = quadgk(t -> ω1_0(t)^2, 0, TRF)[1] / TR\n\n    β = ω1rms^2 / ω1ms_0 - 1\n    if β < 0\n        β = 0\n        @error \"negative Δω1ms with α = $(α*180/pi)deg; on-resonant pulse has ω1rms = $(sqrt(ω1ms_0)). Setting it to zero.\"\n    end\n\n    wt(t) = 1 - sqrt(2 * β) * cos(ω0 * t)\n    ω1(t) = ω1_0(t) * wt(t)\n    return ω1\nend\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"function sech_inversion_pulse(; TRF=10.24e-3, ω₁ᵐᵃˣ=4965.910769033364, μ=5, β=674.1)\n    ω1(t) = ω₁ᵐᵃˣ * sech(β * (t - TRF / 2)) # rad/s\n    ω0(t) = -μ * β * tanh(β * (t - TRF/2)) # rad/s\n    φ_u(t) = μ * log(cosh(β * t) - sinh(β * t) * tanh(β * TRF / 2)) # rad\n    φ(t) = φ_u(t) - φ_u(TRF/2)\n    return (ω1, ω0, φ, TRF)\nend\nnothing #hide","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"Sechn pulse shape according to this paper, confirmed by Dr. O'Brien:","category":"page"},{"location":"build_literate/helper_functions/","page":"Helper functions","title":"Helper functions","text":"function sechn_inversion_pulse(; TRF=10.24e-3, ω₁ᵐᵃˣ=10e-6 * 267.522e6, β=240, μ=35, n = 8)\n    f1(τ) = sech((β * τ)^n)\n    ω1(t) = ω₁ᵐᵃˣ * f1(t - TRF / 2) # rad/s\n\n    ω0_i(t) = μ * β^2 * quadgk((τ) -> f1(τ)^2, 0, t - TRF/2)[1]\n    ω0 = Fun(ω0_i, 0..TRF)\n    φ_ = cumsum(ω0)\n    φ(t) = φ_(t) - φ_(TRF/2)\n    return (ω1, ω0, φ, TRF)\nend\nnothing #hide","category":"page"},{"location":"#Magnetization-transfer-explains-most-of-the-T-variability-in-the-MRI-literature","page":"Home","title":"Magnetization transfer explains most of the T₁ variability in the MRI literature","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This code reproduces all results in the paper Magnetization transfer explains most of the T₁ variability in the MRI literature. The code is written in the open-source language Julia and is structured as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"T₁ Mapping methods contains functions that simulate the MR signal of each T₁-mapping method and fit a mono-exponential T₁ to the simulated data.\nGlobal Fit performs the the fits of the quantitative magnetization transfer parameters to the variable T₁ estimates.\nHelper functions contains implementations of RF pulses and some helper functions, which are less relevant for understanding the simulations. This script also loads all required packages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages=[\n        \"build_literate/Fit_qMT_to_literatureT1.md\",\n        \"build_literate/helper_functions.md\",\n]\nDepth = 2","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"EditURL = \"../../../Fit_qMT_to_literatureT1.jl\"","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#T-Mapping-methods","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"First, we load the required packages and include some Helper functions","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"include(\"helper_functions.jl\")\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Further, we initialize a few empty vectors which will be filled with information about each T₁ mapping method:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"T1_literature = Float64[]\nT1_functions = []\nincl_fit = Bool[]\nseq_name = String[]\nseq_type = Symbol[]\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Next, we define the simulations of each pulse sequence as a function and push this function and auxiliary information to the respective vector.","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#IR:-Stanisz-et-al.","page":"T₁ Mapping methods","title":"IR: Stanisz et al.","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Inversion recovery method described by Stanisz et al. (2005). The following function takes qMT parameters as an input, simulates the signal, performs a mono-exponential T₁ fit as described in the publication, and returns the T₁ estimate. Sequence details are extracted from the publications and complemented with information kindly provided by the authors, as well as educated guesses where the corresponding information was not accessible. The latter two sources are indicated by comments in the functions.","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"function calculate_T1_IRStanisz(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    TRF_inv = 10e-6 # s; 10us - 20us according to private conversations\n    TRF_exc = TRF_inv # guessed, but has a negligible effect\n    TI = exp.(range(log(1e-3), log(32), 35)) # s\n    TD = similar(TI)\n    TD .= 20 # s\n\n    # simulate signal with an MT model\n    u_inv = RF_pulse_propagator(π / TRF_inv, B1, ω0, TRF_inv, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n    u_exc = RF_pulse_propagator(π / 2 / TRF_exc, B1, ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n\n    u_rti = [exp(hamiltonian_linear(0, B1, ω0, iTI - (TRF_inv + TRF_exc) / 2, m0s, R1f, R2f, Rx, R1s, 1)) for iTI ∈ TI]\n    u_rtd = [exp(hamiltonian_linear(0, B1, ω0, iTD - (TRF_inv + TRF_exc) / 2, m0s, R1f, R2f, Rx, R1s, 1)) for iTD ∈ TD]\n\n    s = similar(TI)\n    for i in eachindex(TI)\n        U = u_exc * u_rti[i] * u_inv * u_rtd[i]\n        s[i] = steady_state(U)[1]\n    end\n\n    # fit mono-expential model and return T₁ (in s)\n    model3(t, p) = p[1] .- p[2] .* exp.(-p[3] * t)\n    fit = curve_fit(model3, TI, s, [1, 2, 0.8])\n    return 1 / fit.param[end]\nend","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"We add the literature T₁ value, the function, and some auxiliary data to the above-initialized vectors:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(T1_literature, 1.084) # ± 0.045s in WM\npush!(T1_functions, calculate_T1_IRStanisz)\npush!(seq_name, \"IR Stanisz et al.\")\npush!(seq_type, :IR)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#IR:-Stikhov-et-al.","page":"T₁ Mapping methods","title":"IR: Stikhov et al.","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Inversion recovery method described by Stikhov et al. (2015).","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"function calculate_T1_IRStikhov(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    nLobes = 3 # confirmed by authors\n    TRF_exc = 3.072e-3 # s – confirmed by authors\n    TRF_ref = 3e-3 # s – confirmed by authors\n    TI = [30e-3, 530e-3, 1.03, 1.53] # s\n    TR = 1.55 # s\n    TE = 11e-3 # s\n\n    # simulate signal with an MT model\n    # excitation block\n    u_exc = RF_pulse_propagator(sinc_pulse(-π / 2, TRF_exc; nLobes=nLobes), B1, ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, T2s, MT_model; spoiler=true)\n    u_ref = RF_pulse_propagator(gauss_pulse(π, TRF_ref), B1, ω0, TRF_ref, m0s, R1f, R2f, Rx, R1s, T2s, MT_model; spoiler=false)\n    u_te2 = exp(hamiltonian_linear(0, B1, ω0, (TE - TRF_exc - TRF_ref) / 2, m0s, R1f, R2f, Rx, R1s, 1))\n    u_exc = u_ref * u_te2 * u_exc\n\n    # adiabatic inversion pulse confirmed by the authors\n    ω1, _, φ, TRF_inv = sech_inversion_pulse() # 360 deg, defined by the intgral over the RF's real part.\n    u_inv = RF_pulse_propagator(ω1, B1, φ, TRF_inv, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n\n    # relaxation blocks\n    u_rti = [exp(hamiltonian_linear(0, B1, ω0, iTI - (TRF_inv + TRF_exc) / 2, m0s, R1f, R2f, Rx, R1s, 1)) for iTI ∈ TI]\n    u_rtd = [exp(hamiltonian_linear(0, B1, ω0, TR - iTI - (TRF_inv + TRF_ref + TE) / 2, m0s, R1f, R2f, Rx, R1s, 1)) for iTI ∈ TI]\n\n    s = similar(TI)\n    for i in eachindex(TI)\n        U = u_exc * u_sp * u_rti[i] * u_sp * u_inv * u_sp * u_rtd[i] * u_sp\n        s[i] = steady_state(U)[1]\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    model3(t, p) = p[1] .- p[2] .* exp.(-p[3] * t)\n    fit = curve_fit(model3, TI, s, [1, 2, 0.8])\n    return 1 / fit.param[end]\nend","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(T1_literature, 850e-3) # s – peak of histogram\npush!(T1_functions, calculate_T1_IRStikhov)\npush!(seq_name, \"IR Stikhov et al.\")\npush!(seq_type, :IR)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#IR:-Preibisch-et-al.","page":"T₁ Mapping methods","title":"IR: Preibisch et al.","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Inversion recovery method described by Preibisch et al. (2009).","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"function calculate_T1_IRPreibisch(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    TI = [100, 200, 300, 400, 600, 800, 1000, 1200, 1600, 2000, 2600, 3200, 3800, 4400, 5000] .* 1e-3 # s\n    TD = 20 # s\n    TE = 27e-3 # s\n\n    # The adiabatic inversion pulse was identical to the one described in http://doi.org/10.1002/mrm.20552 (per private communications with Dr. Deichmann)\n    TRF_inv = 8.192e-3 # s\n    β = 4.5 # 1/s\n    μ = 5 # rad\n    ω₁ᵐᵃˣ=13.5*π/TRF_inv # rad/s\n    ω1_inv(t) = ω₁ᵐᵃˣ * sech(β * (2t / TRF_inv - 1)) # rad/s\n    φ_inv(t)  = μ * log(sech(β * (2t / TRF_inv - 1))) # rad\n\n    # simulate signal with an MT model\n    u_inv = RF_pulse_propagator(ω1_inv, B1, φ_inv, TRF_inv, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n\n    # The shape of the excitation pulse was kindly provided by Dr. Deichmann\n    TRF_exc = 2.5e-3 # s\n    _ω1_exc(t) = sinc(2 * abs(2t/TRF_exc-1)^0.88) * cos(π/2 * (2t/TRF_exc-1)) # rad/s\n    ω1_scale = π/2 / quadgk(_ω1_exc, 0, TRF_exc)[1]\n    ω1_exc(t) = _ω1_exc(t) * ω1_scale # rad/s\n    u_exc = RF_pulse_propagator(ω1_exc, B1, ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n    u_te = exp(hamiltonian_linear(0, B1, ω0, TE - TRF_exc / 2, m0s, R1f, R2f, Rx, R1s, 1))\n    u_exc = u_te * u_exc\n\n    # relaxation blocks\n    u_ti = [exp(hamiltonian_linear(0, B1, ω0, iTI - (TRF_inv + TRF_exc) / 2, m0s, R1f, R2f, Rx, R1s, 1)) for iTI ∈ TI]\n    u_td = exp(hamiltonian_linear(0, B1, ω0, TD - TRF_inv / 2 - TE, m0s, R1f, R2f, Rx, R1s, 1))\n\n    s = similar(TI)\n    for i in eachindex(TI)\n        U = u_exc * u_sp * u_ti[i] * u_sp * u_inv * u_sp * u_td * u_sp\n        s[i] = steady_state(U)[1]\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    # Fixed κ per private communications with Dr. Deichmann\n    κ = 1.964\n    model2(t, p) = p[1] .* (1 .- κ .* exp.(-p[2] * t))\n    fit = curve_fit(model2, TI, s, [1, 0.8])\n    return 1 / fit.param[end]\nend","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(T1_literature, 881e-3) # s – median of WM ROIs; mean is 0.882 s\npush!(T1_functions, calculate_T1_IRPreibisch)\npush!(seq_name, \"IR Preibisch et al.\")\npush!(seq_type, :IR)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#IR:-Shin-et-al.","page":"T₁ Mapping methods","title":"IR: Shin et al.","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Inversion recovery method described by Shin et al. (2009).","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"function calculate_T1_IRShin(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    TI = exp.(range(log(34e-3), log(15), 10)) # s – Authors did not recall the TIs, but said they had at least 3–4 short times\n    TR = 30 # s\n    TRF_exc = 2.56e-3 # from Shin's memory\n\n    # simulate signal with an MT model\n    # EPI readout\n    u_exc = RF_pulse_propagator(sinc_pulse(16 / 180 * π, TRF_exc; nLobes=3), B1, ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n\n    # adiabatic inversion pulse\n    ω1, _, φ, TRF_inv = sech_inversion_pulse() # Shin confirmed \"standard Siemens\" adiabatic inversion pulse\n    u_inv = RF_pulse_propagator(ω1, B1, φ, TRF_inv, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n\n    # relaxation blocks\n    u_rti = [exp(hamiltonian_linear(0, B1, ω0, iTI - (TRF_inv + TRF_exc) / 2, m0s, R1f, R2f, Rx, R1s, 1)) for iTI ∈ TI]\n    u_rtd = [exp(hamiltonian_linear(0, B1, ω0, TR - iTI - (TRF_inv + TRF_exc) / 2, m0s, R1f, R2f, Rx, R1s, 1)) for iTI ∈ TI]\n\n    s = similar(TI)\n    for i in eachindex(TI)\n        U = u_exc * u_sp * u_rti[i] * u_sp * u_inv * u_sp * u_rtd[i] * u_sp\n        s[i] = steady_state(U)[1]\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    model3(t, p) = p[1] .- p[2] .* exp.(-p[3] * t)\n    fit = curve_fit(model3, TI, s, [1, 2, 0.8])\n    return 1 / fit.param[end]\nend","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(T1_literature, 0.943) # ± 0.057 s in WM\npush!(T1_functions, calculate_T1_IRShin)\npush!(seq_name, \"IR Shin et al.\")\npush!(seq_type, :IR)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#LL:-Shin-et-al.","page":"T₁ Mapping methods","title":"LL: Shin et al.","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Look-Locker method described by Shin et al. (2009).","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"function calculate_T1_LLShin(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    Nslices = 28 # (inner loop)\n    iSlice = Nslices - 18 # guessed from cf. Fig. 6 and 7, the author suggested that the slices were acquired in ascending order\n\n    TI1 = 12e-3 # s – the author suggested < 12ms\n    TD = 10 + TI1 # s – time duration of data acquisition per IR period\n    TR = 0.4 # s\n    TR_slice = TR / Nslices\n    TI = (0:TR:TD-TR)\n\n    α_exc = 16 * π / 180 # rad\n    TRF_exc = 2.56e-3 # s – from the authors' memory\n    nLobes = 3\n    Δω0 = (nLobes + 1) * 2π / TRF_exc # rad/s\n    ω0slice = ((1:Nslices) .- iSlice) * Δω0\n\n    # simulate signal with an MT model\n    ω1, _, φ, TRF_inv = sech_inversion_pulse() # Shin confirmed \"standard Siemens\" adiabatic inversion pulse\n    u_inv = RF_pulse_propagator(ω1, B1, φ, TRF_inv, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n\n    u_exc = Vector{Matrix{Float64}}(undef, length(ω0slice))\n    Threads.@threads for is ∈ eachindex(ω0slice)\n        if is == iSlice\n            u_exc[is] = RF_pulse_propagator(sinc_pulse(α_exc, TRF_exc; nLobes=nLobes), B1, ω0slice[is] + ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n        else # use Graham's model for off-resonant pulses for speed\n            u_exc[is] = exp(hamiltonian_linear(0, B1, ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, 1))\n            u_exc[is][5, 5] *= exp(-π * quadgk(t -> sinc_pulse(α_exc, TRF_exc; nLobes=nLobes)(t)^2, 0, TRF_exc)[1] * MRIgeneralizedBloch.lineshape_superlorentzian(ω0slice[is] + ω0, T2s))\n        end\n    end\n\n    U = exp(hamiltonian_linear(0, B1, ω0, TI1 - TRF_inv / 2 - TRF_exc / 2, m0s, R1f, R2f, Rx, R1s, 1))\n    for _ ∈ TI, is ∈ eachindex(ω0slice)\n        U = u_exc[is] * u_sp * U\n        U = exp(hamiltonian_linear(0, B1, -ω0slice[is] + ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, 1)) * U # rewind phase\n        U = exp(hamiltonian_linear(0, B1, ω0, TR_slice - 2TRF_exc, m0s, R1f, R2f, Rx, R1s, 1)) * U\n    end\n    U = u_sp * u_inv * u_sp * U\n    m = steady_state(U)\n\n    s = similar(TI)\n    m = exp(hamiltonian_linear(0, B1, ω0, TI1 - TRF_inv / 2 - TRF_exc / 2, m0s, R1f, R2f, Rx, R1s, 1)) * m\n    for iTI ∈ eachindex(s), is ∈ eachindex(ω0slice)\n        m = u_exc[is] * u_sp * m\n        m = exp(hamiltonian_linear(0, B1, -ω0slice[is] + ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, 1)) * m # rewind phase\n        m = exp(hamiltonian_linear(0, B1, ω0, TR_slice - 2TRF_exc, m0s, R1f, R2f, Rx, R1s, 1)) * m\n        if is == iSlice\n            s[iTI] = m[1]\n        end\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    model3(t, p) = p[1] .- p[2] .* exp.(-p[3] * t)\n    fit = curve_fit(model3, TI, s, [1, 2, 0.8])\n    R1a_est = fit.param[end] + log(cos(α_exc)) / TR\n    return 1 / R1a_est\nend","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(T1_literature, 0.964) # ± 116s in WM\npush!(T1_functions, calculate_T1_LLShin)\npush!(seq_name, \"LL Shin et al.\")\npush!(seq_type, :LL)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#IR:-Lu-et-al.","page":"T₁ Mapping methods","title":"IR: Lu et al.","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Inversion-recover method described by Lu et al. (2005).","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"function calculate_T1_IRLu(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    TRF_exc = 1e-3 # s – 0.5-2 ms according to P Zijl\n    TI = [180, 630, 1170, 1830, 2610, 3450, 4320, 5220, 6120, 7010] .* 1e-3 # s\n    TD = 8 # s\n    TE = 42e-3 # s\n\n    # simulate signal with an MT model\n    # excitation block; GRASE RO w/ TSE factor 4\n    u_exc = RF_pulse_propagator(sinc_pulse(π / 2, TRF_exc; nLobes=3), B1, ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, T2s, MT_model; spoiler=true)\n    u_ref = RF_pulse_propagator(sinc_pulse(π, TRF_exc; nLobes=3), B1, ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, T2s, MT_model; spoiler=false)\n    u_te1 = exp(hamiltonian_linear(0, B1, ω0, TE / 4 - TRF_exc, m0s, R1f, R2f, Rx, R1s, 1))\n    u_te234 = exp(hamiltonian_linear(0, B1, ω0, TE / 4 - TRF_exc / 2, m0s, R1f, R2f, Rx, R1s, 1))\n    u_exc = u_te234 * u_ref * u_te234^2 * u_ref * u_te1 * u_exc # 2 refocusing pulses before the RO\n\n    # adiabatic inversion pulse\n    ω1, _, φ, TRF_inv = sech_inversion_pulse(ω₁ᵐᵃˣ=4965.910769033364 * 750 / 360) # nom. α = 750deg according to P. Zijl\n    u_inv = RF_pulse_propagator(ω1, B1, φ, TRF_inv, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n\n    # relaxation blocks\n    u_ti = [exp(hamiltonian_linear(0, B1, ω0, iTI - (TRF_inv + TRF_exc) / 2, m0s, R1f, R2f, Rx, R1s, 1)) for iTI ∈ TI]\n\n    u_et = u_te234 * u_ref * u_te234^2 * u_ref * u_te234 # 2 refocusing pulses after the RO\n    u_td = [exp(hamiltonian_linear(0, B1, ω0, TD - 2TE - TRF_inv / 2, m0s, R1f, R2f, Rx, R1s, 1)) * u_et for _ ∈ TI]\n\n    s = similar(TI)\n    for i in eachindex(TI)\n        U = u_exc * u_sp * u_ti[i] * u_sp * u_inv * u_sp * u_td[i] * u_sp\n        s[i] = abs(steady_state(U)[1])\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    model3(t, p) = abs.(p[1] .* (1 .- p[2] .* exp.(-p[3] * t)))\n    fit = curve_fit(model3, TI, s, [1, 2, 0.8])\n    return 1 / fit.param[end]\nend","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(T1_literature, 0.735) # s; median of WM ROIs; reported T1 = (748 ± 64)ms in the splenium of the CC and (699 ± 38)ms in WM\npush!(T1_functions, calculate_T1_IRLu)\npush!(seq_name, \"IR Lu et al.\")\npush!(seq_type, :IR)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#LL:-Stikhov-et-al.","page":"T₁ Mapping methods","title":"LL: Stikhov et al.","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Look-Locker method described by Stikhov et al. (2015).","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"function calculate_T1_LLStikhov(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    TR = 1.55 # s\n    TI = [30e-3, 530e-3, 1.03, 1.53] # s\n    TRF_inv = 720e-6 # s – for 180deg pulse, 90deg pulse are half as long\n\n    # simulate signal with an MT model\n    u_90  = MRIgeneralizedBloch.xs_destructor(nothing) * RF_pulse_propagator(π / TRF_inv, B1, ω0, TRF_inv / 2, m0s, R1f, R2f, Rx, R1s, T2s, MT_model, spoiler=true)\n    u_inv = MRIgeneralizedBloch.xs_destructor(nothing) * RF_pulse_propagator(π / TRF_inv, B1, ω0, TRF_inv,     m0s, R1f, R2f, Rx, R1s, T2s, MT_model, spoiler=false)\n    u_m90 = MRIgeneralizedBloch.xs_destructor(nothing) * RF_pulse_propagator(π / TRF_inv, B1, ω0, TRF_inv / 2, m0s, R1f, R2f, Rx, R1s, T2s, MT_model, spoiler=false)\n    u_rotp = MRIgeneralizedBloch.z_rotation_propagator(π/2, nothing)\n    u_rotm = MRIgeneralizedBloch.z_rotation_propagator(-π/2, nothing)\n    u_inv = u_rotp * u_m90 * u_rotm * u_inv * u_rotp * u_90  # 90-180-90 pattern confirmed by authors\n    TRF_inv *= 2\n\n    α_exc = 5 * π / 180 # rad\n    nLobes = 7 # confirmed by authors\n    TRF_exc = 2.56e-3 # s – confirmed by authors\n    ω1 = sinc_pulse(α_exc, TRF_exc; nLobes=nLobes)\n    u_exc = RF_pulse_propagator(ω1, B1, ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n\n    dTI = TI .- [0; TI[1:end-1]]\n    dTI[1] -= (TRF_inv + TRF_exc) / 2\n    dTI[2:end] .-= TRF_exc\n\n    u_ir = [exp(hamiltonian_linear(0, B1, ω0, dTI[i], m0s, R1f, R2f, Rx, R1s, 1)) for i in eachindex(dTI)]\n    u_fp = exp(hamiltonian_linear(0, B1, ω0, TR - TI[end] - (TRF_inv + TRF_exc) / 2, m0s, R1f, R2f, Rx, R1s, 1))\n\n    U = I\n    for i in eachindex(TI)\n        U = u_exc * u_ir[i] * U\n    end\n    U = u_inv * u_fp * U\n    m = steady_state(U)\n\n    s = similar(TI)\n    for i in eachindex(TI)\n        m = u_exc * u_ir[i] * m\n        s[i] = m[1]\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    # model as provided by Stikhov et al. in a private communication\n    function model_num(t, p)\n        any(t .!= TI) ? error() : nothing\n\n        cα_exc = cos(α_exc)\n        TI1 = TI[1]\n        TI2 = TI[2] - TI[1]\n        Nll = length(TI)\n\n        tr = TR - TI1 - (Nll - 1) .* TI2 # time between last exc and inv pulse\n\n\n        E1 = exp.(-TI1 ./ p[2])\n        E2 = exp.(-TI2 ./ p[2])\n        Er = exp.(-tr ./ p[2])\n\n        F = (1 - E2) ./ (1 - cα_exc .* E2)\n        Qnom = -F .* cα_exc .* Er .* E1 .* (1 .- (cα_exc .* E2) .^ (Nll - 1)) .- E1 .* (1 .- Er) .- E1 .+ 1\n        Qdenom = 1 .+ cα_exc .* Er .* E1 .* (cα_exc .* E2) .^ (Nll - 1)\n        Q = Qnom / Qdenom\n\n        Mz = zeros(Nll)\n        Msig = zeros(Nll)\n\n        for ii = 1:Nll\n            Mz[ii] = F .+ (cα_exc .* E2) .^ (ii - 1) .* (Q - F)\n            Msig[ii] = p[1] .* sin(α_exc) .* Mz[ii]\n        end\n        return Msig\n    end\n\n    fit = curve_fit(model_num, TI, s, [1.0, 1.0])\n    return fit.param[end]\nend","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(T1_literature, 0.750) # s – peak of histogram; cf. https://doi.org/10.1016/j.mri.2016.08.021\npush!(T1_functions, calculate_T1_LLStikhov)\npush!(seq_name, \"LL Stikhov et al.\")\npush!(seq_type, :LL)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#vFA:-Stikhov-et-al.","page":"T₁ Mapping methods","title":"vFA: Stikhov et al.","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Variable flip-angle method described by Stikhov et al. (2015).","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"function calculate_T1_vFAStikhov(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    α = [3, 10, 20, 30] * π / 180 # rad\n    TR = 15e-3 # s\n    TRF = 2e-3 # s – confirmed by authors\n    nLobes = 9 # confirmed by authors\n\n    # simulate signal with an MT model\n    s = similar(α)\n    for i in eachindex(α)\n        u_exc = RF_pulse_propagator(sinc_pulse(α[i], TRF; nLobes=nLobes), B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n        u_fp = exp(hamiltonian_linear(0, B1, ω0, TR - TRF, m0s, R1f, R2f, Rx, R1s, 1))\n\n        U = u_exc * u_sp * u_fp\n        s[i] = steady_state(U)[1]\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    f = lm(@formula(Y ~ X), DataFrame(X=s ./ tan.(α), Y=s ./ sin.(α)))\n    T1_est = -TR / log(f.model.pp.beta0[2])\n    return T1_est\nend","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(T1_literature, 1.07) # s – peak of histogram (cf. https://doi.org/10.1016/j.mri.2016.08.021)\npush!(T1_functions, calculate_T1_vFAStikhov)\npush!(seq_name, \"vFA Stikhov et al.\")\npush!(seq_type, :vFA)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#vFA:-Cheng-et-al.","page":"T₁ Mapping methods","title":"vFA: Cheng et al.","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Variable flip-angle method described by Cheng et al. (2006).","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"function calculate_T1_vFACheng(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    α = [2, 9, 19] * π / 180 # rad\n    TR = 6.1e-3 # s\n    TRF = 1e-3 # s – guessed\n    nLobes = 3 # guessed\n\n    # simulate signal with an MT model\n    s = similar(α)\n    for i in eachindex(α)\n        u_exc = RF_pulse_propagator(sinc_pulse(α[i], TRF; nLobes=nLobes), B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n        u_fp = exp(hamiltonian_linear(0, B1, ω0, TR - TRF, m0s, R1f, R2f, Rx, R1s, 1))\n\n        U = u_exc * u_sp * u_fp\n        s[i] = steady_state(U)[1]\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    f = lm(@formula(Y ~ X), DataFrame(X=s ./ tan.(α), Y=s ./ sin.(α)))\n    T1_est = -TR / log(f.model.pp.beta0[2])\n    return T1_est\nend","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(T1_literature, 1.0855) # s – mean of two volunteers\npush!(T1_functions, calculate_T1_vFACheng)\npush!(seq_name, \"vFA Cheng et al.\")\npush!(seq_type, :vFA)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#vFA:-Chavez-and-Stanisz","page":"T₁ Mapping methods","title":"vFA: Chavez & Stanisz","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Variable flip-angle method described by Chavez & Stanisz (2012).","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"function calculate_T1_vFA_Chavez(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    α = [1, 40, 130, 150] * π / 180 # rad\n    TR = 40e-3 # s\n\n    # simulate signal with an MT model\n    s = similar(α)\n    for i in eachindex(α)\n        TRF = α[i] / (π/0.5e-3) # s – guessed, incl. constant ω1 / variable TRF\n        u_exc = RF_pulse_propagator(α[i]/TRF, B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, T2s, MT_model) # rect. pulse shape guessed because \"slab-select gradient [...] [is] turned off\"\n        u_fp = exp(hamiltonian_linear(0, B1, ω0, TR - TRF, m0s, R1f, R2f, Rx, R1s, 1))\n\n        U = u_exc * u_sp * u_fp\n        s[i] = steady_state(U)[1]\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    # NLLS fit as described in the paper\n    function vFA_signal(α, p)\n        S0, B1, T1 = p\n        E1 = exp(-TR / T1)\n        return S0 .* sin.(B1 .* α) .* (1 - E1) ./ (1 .- cos.(B1 .* α) .* E1)\n    end\n\n    fit_vFA = curve_fit(vFA_signal, α, s, ones(3))\n    return fit_vFA.param[end]\nend","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(T1_literature, 1.044) # s; median of corpus callosum ROIs\npush!(T1_functions, calculate_T1_vFA_Chavez)\npush!(seq_name, \"vFA Chavez & Stanisz\")\npush!(seq_type, :vFA)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#vFA:-Preibisch-et-al.","page":"T₁ Mapping methods","title":"vFA: Preibisch et al.","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Variable flip-angle method described by Preibisch et al. (2009).","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"function calculate_T1_vFAPreibisch(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    α = [4, 18] * π / 180 # rad\n    TR = 7.6e-3 # s\n    TRF = 0.2e-3 # s – confirmed by Dr. Deichmann\n\n    # simulate signal with an MT model\n    s = similar(α)\n    for i in eachindex(α)\n        u_exc = RF_pulse_propagator(α[i] / TRF, B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n        u_fp = exp(hamiltonian_linear(0, B1, ω0, (TR - TRF) / 2, m0s, R1f, R2f, Rx, R1s, 1))\n\n        U = u_fp * u_exc * u_fp\n        s[i] = steady_state(U)[1]\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    f = lm(@formula(Y ~ X), DataFrame(X=s .* α, Y=s ./ α))\n    T1_est = -2 * TR * f.model.pp.beta0[2]\n    return T1_est\nend","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(T1_literature, 0.940) # s; median of ROIs; mean = 0.951s\npush!(T1_functions, calculate_T1_vFAPreibisch)\npush!(seq_name, \"vFA Preibisch et al.\")\npush!(seq_type, :vFA)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#vFA-Hybrid-FLASH-EPI:-Preibisch-et-al.","page":"T₁ Mapping methods","title":"vFA - Hybrid FLASH-EPI: Preibisch et al.","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Variable flip-angle method with a Hybrid FLASH-EPI readout described by Preibisch et al. (2009).","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"function calculate_T1_vFAPreibisch_HYB(m0s, R1f, R2f, Rx, R1s, T2s, α, TR)\n    # define sequence parameters\n    TRF = 0.2e-3 # s – confirmed by Dr. Deichmann\n\n    # simulate signal with an MT model\n    s = similar(α)\n    for i in eachindex(α)\n        u_exc = RF_pulse_propagator(α[i] / TRF, B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n        u_fp = exp(hamiltonian_linear(0, B1, ω0, (TR - TRF) / 2, m0s, R1f, R2f, Rx, R1s, 1))\n        U = u_fp * u_exc * u_fp\n        s[i] = steady_state(U)[1]\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    SL = (s[2]/sin(α[2]) - s[1]/sin(α[1])) / (s[2]/tan(α[2]) - s[1]/tan(α[1]))\n    T1_est = -TR / log(SL)\n    return T1_est\nend","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"For this sequence, we simulate three different settings with different flip angles and repetition times:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(T1_literature, 0.955) # s\npush!(T1_functions, (m0s, R1f, R2f, Rx, R1s, T2s) -> calculate_T1_vFAPreibisch_HYB(m0s, R1f, R2f, Rx, R1s, T2s, [4, 22] .* π ./ 180, 12.5e-3))\npush!(seq_name, \"vFA HYB12.5ms Preibisch et al.\")\npush!(seq_type, :vFA)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(T1_literature, 0.949) # s\npush!(T1_functions, (m0s, R1f, R2f, Rx, R1s, T2s) -> calculate_T1_vFAPreibisch_HYB(m0s, R1f, R2f, Rx, R1s, T2s, [4, 24] .* π ./ 180, 15.2e-3))\npush!(seq_name, \"vFA HYB15.2ms Preibisch et al.\")\npush!(seq_type, :vFA)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(T1_literature, 0.959) # s\npush!(T1_functions, (m0s, R1f, R2f, Rx, R1s, T2s) -> calculate_T1_vFAPreibisch_HYB(m0s, R1f, R2f, Rx, R1s, T2s, [4, 25] .* π ./ 180, 15.9e-3))\npush!(seq_name, \"vFA HYB15.9ms Preibisch et al.\")\npush!(seq_type, :vFA)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#vFA:-Teixeira-et-al.","page":"T₁ Mapping methods","title":"vFA: Teixeira et al.","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Variable flip-angle method described by Teixeira et al. (2019)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"function calculate_T1_vFATeixeira(m0s, R1f, R2f, Rx, R1s, T2s, ω1rms)\n    # define sequence parameters\n    α = [6, 12, 18] * π / 180 # rad – provided Dr. Teixeira\n    TR = 15e-3 # s – provided by Dr. Teixeira for Fig. 7\n    TRF = 3e-3 # s – confirmed by Dr. Teixeira\n    ω0_CSMT = 6e3 * 2π # 6kHz – confirmed by Dr. Teixeira\n\n    # simulate signal with an MT model\n    s = similar(α)\n    Threads.@threads for i in eachindex(α)\n        u_exc = RF_pulse_propagator(CSMT_pulse(α[i], TRF, TR, ω1rms, ω0=ω0_CSMT), B1, ω0, TRF, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n        u_fp = exp(hamiltonian_linear(0, B1, ω0, (TR - TRF) / 2, m0s, R1f, R2f, Rx, R1s, 1))\n\n        U = u_fp * u_exc * u_fp\n        s[i] = steady_state(U)[1]\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    f = lm(@formula(Y ~ X), DataFrame(X=s ./ tan.(α), Y=s ./ sin.(α))) # DESPOT1 confirmed by Dr. Teixeira\n    T1_est = -TR / log(f.model.pp.beta0[2])\n    return T1_est\nend","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"For this sequence, we simulate five different B₁-RMS values:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(T1_literature, 0.825) # s – read from Fig. 7\npush!(T1_functions, (m0s, R1f, R2f, Rx, R1s, T2s) -> calculate_T1_vFATeixeira(m0s, R1f, R2f, Rx, R1s, T2s, 0.4e-6 * 267.522e6)) # rad/s\npush!(seq_name, \"vFA CSMT w/ B1rms = 0.4uT Teixeira et al.\")\npush!(seq_type, :vFA)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(T1_literature, 0.775) # s – read from Fig. 7\npush!(T1_functions, (m0s, R1f, R2f, Rx, R1s, T2s) -> calculate_T1_vFATeixeira(m0s, R1f, R2f, Rx, R1s, T2s, 0.8e-6 * 267.522e6)) # rad/s\npush!(seq_name, \"vFA CSMT w/ B1rms = 0.8uT Teixeira et al.\")\npush!(seq_type, :vFA)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(T1_literature, 0.73) # s – read from Fig. 7\npush!(T1_functions, (m0s, R1f, R2f, Rx, R1s, T2s) -> calculate_T1_vFATeixeira(m0s, R1f, R2f, Rx, R1s, T2s, 1.2e-6 * 267.522e6)) # rad/s\npush!(seq_name, \"vFA CSMT w/ B1rms = 1.2uT Teixeira et al.\")\npush!(seq_type, :vFA)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(T1_literature, 0.68) # s – read from Fig. 7\npush!(T1_functions, (m0s, R1f, R2f, Rx, R1s, T2s) -> calculate_T1_vFATeixeira(m0s, R1f, R2f, Rx, R1s, T2s, 1.6e-6 * 267.522e6)) # rad/s\npush!(seq_name, \"vFA CSMT w/ B1rms = 1.6uT Teixeira et al.\")\npush!(seq_type, :vFA)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(T1_literature, 0.64) # s – read from Fig. 7\npush!(T1_functions, (m0s, R1f, R2f, Rx, R1s, T2s) -> calculate_T1_vFATeixeira(m0s, R1f, R2f, Rx, R1s, T2s, 2e-6 * 267.522e6)) # rad/s\npush!(seq_name, \"vFA CSMT w/ B1rms = 2uT Teixeira et al.\")\npush!(seq_type, :vFA)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#MP2RAGE:-Marques-et-al.","page":"T₁ Mapping methods","title":"MP2RAGE: Marques et al.","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"MP₂RAGE method described by Marques et al. (2010).","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"function calculate_T1_MP2RAGE(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    α = [4, 5] .* π / 180 # rad\n    TRl = 6.75 # s\n    TR_FLASH = 7.9e-3 # s\n    TI = [0.8, 3.2] # s\n    Nz = 160 ÷ 3\n\n    # simulate signal with an MT model\n    # adiabatic inversion pulse\n    ω1, _, φ, TRF_inv = sechn_inversion_pulse(n=8, ω₁ᵐᵃˣ=25e-6 * 267.522e6) # HS8 pulse confirmed by Dr. Marques; amplitude chosen close to the max. of a typical 3T system\n    u_inv = u_sp * RF_pulse_propagator(ω1, B1, φ, TRF_inv, m0s, R1f, R2f, Rx, R1s, T2s, MT_model) * u_sp\n\n    ta = TI[1] - Nz / 2 * TR_FLASH - TRF_inv / 2\n    tb = TI[2] - TI[1] - Nz * TR_FLASH\n    tc = TRl - TI[2] - Nz / 2 * TR_FLASH - TRF_inv / 2\n\n    u_ta = exp(hamiltonian_linear(0, B1, ω0, ta, m0s, R1f, R2f, Rx, R1s, 1))\n    u_tb = exp(hamiltonian_linear(0, B1, ω0, tb, m0s, R1f, R2f, Rx, R1s, 1))\n    u_tc = exp(hamiltonian_linear(0, B1, ω0, tc, m0s, R1f, R2f, Rx, R1s, 1))\n\n    # excitation blocks\n    # binomial water excitation pulses; 1-2-1 pulse scheme confirmed for the Siemens product sequence; not specifically for the prototype.\n    TRF_bin = 0.2e-3 # s – guessed, but has little influence the estimated T1\n    τ = 1 / (2 * 430) - TRF_bin # s – fat-water shift = 440Hz\n    TRF_exc = 2τ + 3TRF_bin # s\n\n    u_1 = RF_pulse_propagator(α[1] / 4 / TRF_bin, B1, ω0, TRF_bin, m0s, R1f, R2f, Rx, R1s, T2s, MT_model, spoiler=false)\n    u_2 = RF_pulse_propagator(2α[1] / 4 / TRF_bin, B1, ω0, TRF_bin, m0s, R1f, R2f, Rx, R1s, T2s, MT_model, spoiler=false)\n    u_t = exp(hamiltonian_linear(0, B1, ω0, τ, m0s, R1f, R2f, Rx, R1s, 1))\n    u_exc1 = u_1 * u_t * u_2 * u_t * u_1\n\n    u_1 = RF_pulse_propagator(α[2] / 4 / TRF_bin, B1, ω0, TRF_bin, m0s, R1f, R2f, Rx, R1s, T2s, MT_model, spoiler=false)\n    u_2 = RF_pulse_propagator(2α[2] / 4 / TRF_bin, B1, ω0, TRF_bin, m0s, R1f, R2f, Rx, R1s, T2s, MT_model, spoiler=false)\n    u_t = exp(hamiltonian_linear(0, B1, ω0, τ, m0s, R1f, R2f, Rx, R1s, 1))\n    u_exc2 = u_1 * u_t * u_2 * u_t * u_1\n\n    u_te = exp(hamiltonian_linear(0, B1, ω0, (TR_FLASH - TRF_exc) / 2, m0s, R1f, R2f, Rx, R1s, 1))\n    u_exc1 = u_te * u_exc1 * u_sp * u_te\n    u_exc2 = u_te * u_exc2 * u_sp * u_te\n\n    # Propagation matrix in temporal order:\n    # U = u_tc * u_exc2^Nz * u_tb * u_exc1^Nz * u_ta * u_inv\n    U1 = u_exc1^(Nz / 2) * u_ta * u_inv * u_tc * u_exc2^Nz * u_tb * u_exc1^(Nz / 2)\n    U2 = u_exc2^(Nz / 2) * u_tb * u_exc1^Nz * u_ta * u_inv * u_tc * u_exc2^(Nz / 2)\n\n    s1 = steady_state(U1)[1]\n    s2 = steady_state(U2)[1]\n    sm = s1' * s2 / (abs(s1)^2 + abs(s2)^2)\n\n    # fit mono-expential model and return T1 (in s)\n    function MP2RAGE_signal(T1)\n        eff_inv = 0.96 # from paper\n\n        E1 = exp(-TR_FLASH / T1)\n        EA = exp(-ta / T1)\n        EB = exp(-tb / T1)\n        EC = exp(-tc / T1)\n\n        mzss = (((((1 - EA) * (cos(α[1]) * E1)^Nz + (1 - E1) * (1 - (cos(α[1]) * E1)^Nz) / (1 - cos(α[1]) * E1)) * EB + (1 - EB)) * (cos(α[2]) * E1)^Nz + (1 - E1) * (1 - (cos(α[2]) * E1)^Nz) / (1 - cos(α[2]) * E1)) * EC + (1 - EC)) / (1 + eff_inv * (cos(α[1]) * cos(α[2]))^Nz * exp(-TRl / T1))\n\n        s1 = sin(α[1]) * ((-eff_inv * mzss * EA + (1 - EA)) * (cos(α[1]) * E1)^(Nz / 2 - 1) + (1 - E1) * (1 - (cos(α[1]) * E1)^(Nz / 2 - 1)) / (1 - cos(α[1]) * E1))\n        s2 = sin(α[2]) * ((mzss - (1 - EC)) / (EC * (cos(α[2]) * E1)^(Nz / 2)) - (1 - E1) * ((cos(α[2]) * E1)^(-Nz / 2) - 1) / (1 - cos(α[2]) * E1))\n\n        sm = s1' * s2 / (abs(s1)^2 + abs(s2^2))\n        return sm\n    end\n\n    fit = curve_fit((_, T1) -> MP2RAGE_signal.(T1), [1], [sm], [0.5])\n    return fit.param[1]\nend","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(T1_literature, 0.81) # ± 0.03 s\npush!(T1_functions, calculate_T1_MP2RAGE)\npush!(seq_name, \"MP2RAGE Marques et al.\")\npush!(seq_type, :MP2RAGE)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"MPRAGE: Wright et al. MPRAGE method described by Wright et al. (2008).","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"function calculate_T1_MPRAGE_Wright(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    TRl = 5 # s\n    TR_FLASH = 11e-3 # s\n    TE = 6.7e-3 # s\n    TI = [160, 190, 285, 441, 680, 1050, 1619, 2100] .* 1e-3 # s\n    Nz = 256\n\n    # simulate signal with an MT model\n    # adiabatic inversion pulse\n    TRF_inv = 13.5e-3 # s – from the paper\n    β = 600 # 1/s – picked for 10kHz bandwidth\n    μ = 5  # rad – 50 rad would match 10 kHz bandwidth, 5 rad chosen for computation speed (makes little difference)\n    ω₁ᵐᵃˣ = 4 * sqrt(μ) * β # rad/s – compromise of appromximating 1.25 >> 1 and keeping B1max in limits\n    ω1, _, φ, TRF_inv = sech_inversion_pulse(TRF=TRF_inv, β=β, μ=μ, ω₁ᵐᵃˣ=ω₁ᵐᵃˣ) # standard Philips inverson pulse, likely hyperbolic secant, as confirmed by Dr. Gowland\n    u_inv = u_sp * RF_pulse_propagator(ω1, B1, φ, TRF_inv, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n\n    # excitation blocks\n    α = (8/20:8/20:8) .* π / 180 # rad – pattern confirmed by Dr. Gowland\n    TRF_exc = 0.67e-3 # s\n    nLobes = 7 # sinc pulses confirmed by Dr. Gowland; number of lobes guessed guessed to approximate the 11.9kHz bandwidth discussed in the paper\n\n    u_exc = [RF_pulse_propagator(sinc_pulse(α[i], TRF_exc; nLobes=nLobes), B1, ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, T2s, MT_model) for i in eachindex(α)]\n    u_te = exp(hamiltonian_linear(0, B1, ω0, TE - TRF_exc / 2, m0s, R1f, R2f, Rx, R1s, 1))\n    u_tr = exp(hamiltonian_linear(0, B1, ω0, TR_FLASH - TE - TRF_exc / 2, m0s, R1f, R2f, Rx, R1s, 1))\n    u_exc = [u_te * u_exc[i] * u_tr for i in eachindex(u_exc)]\n    u_exc_ramp = prod(u_exc[end:-1:1])\n\n    s = similar(TI)\n    for iTI in eachindex(TI)\n        ti = TI[iTI] - TRF_inv / 2 - (TR_FLASH - TE) - length(α) * TR_FLASH\n        tc = TRl - TI[iTI] - Nz * TR_FLASH - TRF_inv / 2 - TE + length(α) * TR_FLASH\n\n        u_ti = exp(hamiltonian_linear(0, B1, ω0, ti, m0s, R1f, R2f, Rx, R1s, 1))\n        u_tc = exp(hamiltonian_linear(0, B1, ω0, tc, m0s, R1f, R2f, Rx, R1s, 1))\n\n        # Propagation matrix in temporal order: U = u_tc * u_exc20^(Nz-20) * ... u_exc2 * u_exc1 * u_ti * u_inv\n        U = u_exc_ramp * u_ti * u_inv * u_tc * u_exc[end]^(Nz - length(α))\n        s[iTI] = steady_state(U)[1] # extract x-magnetization\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    function MPRAGE_mz(TI, p)\n        T1, M0, α_inv = p\n\n        function hamiltonian_T1(T, R1)\n            H = @SMatrix [\n                -R1  R1;\n                  0   0]\n            return H * T\n        end\n        function pulse_propgator(α)\n            U = @SMatrix [\n                cos(α)  0;\n                     0  1]\n            return U\n        end\n        function steady_state_2D(U)\n            Q = U - @SMatrix [1 0; 0 0]\n            m = Q \\ @SVector [0,1]\n            return m\n        end\n\n        s = similar(TI)\n        for iTI in eachindex(TI)\n            ti = TI[iTI] - length(α) * TR_FLASH\n            tc = TRl - TI[iTI] - Nz * TR_FLASH + length(α) * TR_FLASH\n\n            u_ti = exp(hamiltonian_T1(ti, 1/T1))\n            u_tr = exp(hamiltonian_T1(TR_FLASH, 1/T1))\n            u_tc = exp(hamiltonian_T1(tc, 1/T1))\n\n            # Propagation matrix in temporal order: U = u_tc * u_exc20^(Nz-20) * ... u_exc2 * u_exc1 * u_ta * u_inv\n            U = u_tr * pulse_propgator(α[end])\n            for i in (length(α)-1):-1:1\n                U = U * u_tr * pulse_propgator(α[i])\n            end\n            U = U * u_ti * pulse_propgator(α_inv) * u_tc * (u_tr * pulse_propgator(α[end]))^(Nz - length(α))\n            s[iTI] = M0 * steady_state_2D(U)[1] # extract z-magnetization\n        end\n        return s\n    end\n\n    fit = curve_fit(MPRAGE_mz, TI, s, [1, sin(α[end]), 0.9π])\n    return fit.param[1]\nend","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(T1_literature, 0.84) # s\npush!(T1_functions, calculate_T1_MPRAGE_Wright)\npush!(seq_name, \"MPRAGE Wright et al.\")\npush!(seq_type, :MP2RAGE)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Adiabatic-IR:-Wright-et-al.","page":"T₁ Mapping methods","title":"Adiabatic IR: Wright et al.","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Inversion-recovery method with adiabatic inversion pulse described by Wright et al. (2008).","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"function calculate_T1_IR_EPI_Wright(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    TI = [120, 200, 400, 600, 900, 1500, 2100, 3000, 4000] .* 1e-3 # s\n    TR = 35 # s\n    TE = 45e-3 # s\n    TRF_exc = 7.7e-3 # s\n    nLobes = 1 # chose to match 395 Hz bandwidth\n\n    # simulate signal with an MT model\n    # adiabatic inversion pulse\n    TRF_inv = 17.51e-3 # s\n    β = 500 # 1/s – chosen to fit 713Hz bandwidth\n    μ = 5   # rad – chosen to fit 713Hz bandwidth\n    ω₁ᵐᵃˣ = 2 * sqrt(μ) * β # rad/s – compromise of appromximating 2 >> 1 and keeping B1max in limits\n    ω1, _, φ, TRF_inv = sech_inversion_pulse(TRF=TRF_inv, β=β, μ=μ, ω₁ᵐᵃˣ=ω₁ᵐᵃˣ)\n    u_inv = u_sp * RF_pulse_propagator(ω1, B1, φ, TRF_inv, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n\n    # relaxation blocks\n    u_ti = [exp(hamiltonian_linear(0, B1, ω0, iTI - TRF_inv/2 - TRF_exc/2, m0s, R1f, R2f, Rx, R1s, 1)) for iTI ∈ TI]\n    u_td = [exp(hamiltonian_linear(0, B1, ω0,  TR - TRF_inv/2 - iTI - TE , m0s, R1f, R2f, Rx, R1s, 1)) for iTI ∈ TI]\n\n    # excitation block\n    u_exc = RF_pulse_propagator(sinc_pulse(π / 2, TRF_exc; nLobes=nLobes), B1, ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n    u_te = exp(hamiltonian_linear(0, B1, ω0, TE - TRF_exc / 2, m0s, R1f, R2f, Rx, R1s, 1))\n    u_exc = u_te * u_exc\n\n    s = similar(TI)\n    for i in eachindex(TI)\n        U = u_exc * u_sp * u_ti[i] * u_sp * u_inv * u_sp * u_td[i] * u_sp\n        s[i] = steady_state(U)[1]\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    model3(t, p) = p[1] .* (1 .- p[2] .* exp.(-p[3] * t)) # p[2] = (1 - cos(α))\n    fit = curve_fit(model3, TI, s, [1, 2, 0.8])\n    return 1 / fit.param[end]\nend","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(T1_literature, 0.9) # s – read from Fig. 5\npush!(T1_functions, calculate_T1_IR_EPI_Wright)\npush!(seq_name, \"IR EPI Wright et al.\")\npush!(seq_type, :IR)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Adiabatic-IR:-Reynolds-et-al.","page":"T₁ Mapping methods","title":"Adiabatic IR: Reynolds et al.","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Inversion-recovery method with adiabatic inversion pulse described by Reynolds et al. (2023).","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"function calculate_T1_IRReynolds_adiabatic(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    TRF_exc = 1e-3 # s – guessed\n    nLobes = 3 # s – guessed\n    TI = [5.5, 10.2, 35.8, 66.9, 125, 234, 598, 818, 1118, 1529, 3910, 5348] .* 1e-3 # s – measured from end to beginning of respective pulse (confirmed by Dr. Reynolds)\n    TD = 5 # s\n    TE = 10e-3 # s – guessed, but has negligible impact\n\n    # simulate signal with an MT model\n    # adiabatic inversion pulse\n    ω1, _, φ, TRF_inv = sech_inversion_pulse(TRF=10e-3, ω₁ᵐᵃˣ=13.5e-6 * 267.522e6, μ=1.8380981750265004, β=730)\n    u_inv = RF_pulse_propagator(ω1, B1, φ, TRF_inv, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n\n    # relaxation blocks\n    u_ti = [exp(hamiltonian_linear(0, B1, ω0, iTI, m0s, R1f, R2f, Rx, R1s, 1)) for iTI ∈ TI]\n    u_td = exp(hamiltonian_linear(0, B1, ω0, TD - TE, m0s, R1f, R2f, Rx, R1s, 1))\n\n    # excitation block\n    u_exc = RF_pulse_propagator(sinc_pulse(π / 2, TRF_exc; nLobes=nLobes), B1, ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n    u_te = exp(hamiltonian_linear(0, B1, ω0, TE - TRF_exc / 2, m0s, R1f, R2f, Rx, R1s, 1))\n    u_exc = u_te * u_exc\n\n    s = similar(TI)\n    for i in eachindex(TI)\n        U = u_exc * u_sp * u_ti[i] * u_sp * u_inv * u_sp * u_td * u_sp\n        s[i] = steady_state(U)[1]\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    model3(t, p) = p[1] .* (1 .- p[2] .* exp.(-p[3] * t)) # confirmed by Dr. Reynolds\n    fit = curve_fit(model3, TI, s, [1, 2, 0.8])\n    return 1 / fit.param[end]\nend","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(T1_literature, 0.905) # s\npush!(T1_functions, calculate_T1_IRReynolds_adiabatic)\npush!(seq_name, \"IR ad. Reynolds et al.\")\npush!(seq_type, :IR)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Sinc-IR:-Reynolds-et-al.","page":"T₁ Mapping methods","title":"Sinc IR: Reynolds et al.","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Inversion-recovery method with a sinc inversion pulse described by Reynolds et al. (2023).","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"function calculate_T1_IRReynolds_sinc(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    TRF_exc = 1e-3 # s – guessed\n    nLobes_exc = 3 # s – guessed\n    TI = [5.5, 10.2, 35.8, 66.9, 125, 234, 598, 818, 1118, 1529, 3910, 5348] .* 1e-3 # s – measured from end to beginning of respective pulse (confirmed by Dr. Reynolds)\n    TD = 5 # s\n    TE = 10e-3 # s – guessed, but has negligible impact\n\n    # simulate signal with an MT model\n    # excitation block\n    u_exc = RF_pulse_propagator(sinc_pulse(π / 2, TRF_exc; nLobes=nLobes_exc), B1, ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n    u_te = exp(hamiltonian_linear(0, B1, ω0, TE - TRF_exc / 2, m0s, R1f, R2f, Rx, R1s, 1))\n    u_exc = u_te * u_exc\n\n    # sinc inversion pulse\n    TRF_inv = 3e-3 # s\n    nLobes_inv = 3\n    u_inv = RF_pulse_propagator(sinc_pulse(π, TRF_inv; nLobes=nLobes_inv), B1, ω0, TRF_inv, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n\n    # relaxation blocks\n    u_ti = [exp(hamiltonian_linear(0, B1, ω0, iTI, m0s, R1f, R2f, Rx, R1s, 1)) for iTI ∈ TI]\n    u_td = exp(hamiltonian_linear(0, B1, ω0, TD - TE, m0s, R1f, R2f, Rx, R1s, 1))\n\n    s = similar(TI)\n    for i in eachindex(TI)\n        U = u_exc * u_sp * u_ti[i] * u_sp * u_inv * u_sp * u_td * u_sp\n        s[i] = steady_state(U)[1]\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    model3(t, p) = p[1] .* (1 .- p[2] .* exp.(-p[3] * t)) # confirmed by Rd. Reynolds\n    fit = curve_fit(model3, TI, s, [1, 2, 0.8])\n    return 1 / fit.param[end]\nend","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(T1_literature, 0.861) # s\npush!(T1_functions, calculate_T1_IRReynolds_sinc)\npush!(seq_name, \"IR sinc Reynolds et al.\")\npush!(seq_type, :IR)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#SR:-Reynolds-et-al.","page":"T₁ Mapping methods","title":"SR: Reynolds et al.","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Saturation recovery method described by Reynolds et al. (2023).","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"function calculate_T1_SRReynolds(m0s, R1f, R2f, Rx, R1s, T2s)\n    # define sequence parameters\n    TRF_exc = 1e-3 # s – guessed, but has negligible impact\n    nLobes_exc = 5 # guessed, but has negligible impact\n    TI = [5.5, 10.2, 35.8, 66.9, 125, 234, 598, 818, 1118, 1529, 3910, 5348] .* 1e-3 # s – measured from end to beginning of respective pulse (confirmed by Dr. Reynolds)\n    TD = 5 # s\n    TE = 10e-3 # s – guessed, but has negligible impact\n\n    # simulate signal with an MT model\n    # saturation pulse\n    TRF_sat = 0.5 # s\n    ω1 = 10 * 2π # rad/s\n    u_sat = RF_pulse_propagator(ω1, B1, ω0, TRF_sat, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n\n    # relaxation blocks\n    u_ti = [exp(hamiltonian_linear(0, B1, ω0, iTI, m0s, R1f, R2f, Rx, R1s, 1)) for iTI ∈ TI]\n    u_td = exp(hamiltonian_linear(0, B1, ω0, TD - TE, m0s, R1f, R2f, Rx, R1s, 1))\n\n    # excitation block\n    u_exc = RF_pulse_propagator(sinc_pulse(π / 2, TRF_exc; nLobes=nLobes_exc), B1, ω0, TRF_exc, m0s, R1f, R2f, Rx, R1s, T2s, MT_model)\n    u_te = exp(hamiltonian_linear(0, B1, ω0, TE - TRF_exc / 2, m0s, R1f, R2f, Rx, R1s, 1))\n    u_exc = u_te * u_exc\n\n    s = similar(TI)\n    for i in eachindex(TI)\n        U = u_exc * u_ti[i] * u_sp * u_sat * u_td * u_sp\n        s[i] = steady_state(U)[1]\n    end\n\n    # fit mono-expential model and return T1 (in s)\n    model3(t, p) = p[1] .* (1 .- p[2] .* exp.(-p[3] * t)) # confirmed by Dr. Reynolds\n    fit = curve_fit(model3, TI, s, [1, 2, 0.8])\n    return 1 / fit.param[end]\nend","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(T1_literature, 1.013) # s\npush!(T1_functions, calculate_T1_SRReynolds)\npush!(seq_name, \"SR Reynolds et al.\")\npush!(seq_type, :SR)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Global-Fit","page":"T₁ Mapping methods","title":"Global Fit","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Initialize-plot-and-output-of-the-fit","page":"T₁ Mapping methods","title":"Initialize plot and output of the fit","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"p = plot([0.55, 1.15], [0.55, 1.15], xlabel=\"T1 simulated\", ylabel=\"T1 measured\", legend=:topleft, label=:none)\nmarker_list = [(seq_type_i == :IR) ? (:circle) : ((seq_type_i == :LL) ? (:cross) : ((seq_type_i == :vFA) ? (:diamond) : ((seq_type_i == :SR) ? (:dtriangle) : (:x)))) for seq_type_i in seq_type]\n\nfit_name = String[]\nfitted_param = NTuple{6, Float64}[]\nT1_simulated = Array{Float64}[]\nΔAIC_v = Float64[]\nΔBIC_v = Float64[]\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Mono-exponential-fit","page":"T₁ Mapping methods","title":"Mono-exponential fit","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"We simulate the mono-exponential model as an MT model with a vanishing semi-solid spin pool. In this case, the underlying MT model is irrelevant and we choose Graham's model for speed purposes:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"MT_model = Graham()\npush!(fit_name, \"mono_exp\")\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"The following parameters are hard-coded with the exception of R1f, which serves as an initialization for the global fit.","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"m0s = 0\nR1f = 1 / 1.084  # 1/s\nR2f = 1 / 0.0769 # 1/s\nRx = 0           # 1/s\nR1s = R1f        # 1/s\nT2s = 0\nω0 = 0\nB1 = 1\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"We define a model for the global fit. It takes the global set of parameters p as an input and returns a vector of T₁ estimates that correspond to the T₁ mapping methods described by the vector T1_functions","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"function model(iseq, p)\n    R1f = p[1]\n    T1 = similar(iseq, Float64)\n    Threads.@threads for i in eachindex(iseq)\n        T1[i] = T1_functions[iseq[i]](m0s, R1f, R2f, Rx, R1s, T2s)\n    end\n    return T1\nend","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Perform the fit and save the global set of parameters:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"fit_mono = curve_fit(model, 1:length(T1_literature), T1_literature, [R1f], x_tol=1e-3)\npush!(fitted_param, (m0s, fit_mono.param[1], R2f, Rx, R1s, T2s))\npush!(T1_simulated, model(1:length(T1_literature), fit_mono.param))\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"For this model, the global set of parameters is:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"m0s","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"R1f_fitted = fit_mono.param[1]","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"R2f","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Rx","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"R1s","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"T2s","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"where all but R1f are fixed. The following plot visualizes the quality of the fit an replicates Fig. 1 in the manuscript:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"scatter!(p, T1_simulated[end], T1_literature, label=\"$(fit_name[end]) model\", markershape=marker_list, hover=seq_name)\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria","page":"T₁ Mapping methods","title":"Akaike (AIC) and Bayesian (BIC) information criteria","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"The information criteria depend on the number of measurements n, the number of parameters k, and the squared sum of the residuals RSS:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"n = length(T1_literature)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"k = length(fit_mono.param)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"RSS = norm(fit_mono.resid)^2","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"As the AIC and BIC are only informative in the difference, between two models, we use the mono-exponential model as the reference:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"AIC_mono = n * log(RSS / n) + 2k","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"BIC_mono = n * log(RSS / n) + k * log(n)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"In this case, ΔAIC is per definition zero:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"ΔAIC = n * log(RSS / n) + 2k - AIC_mono","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"as is ΔBIC:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"ΔBIC = n * log(RSS / n) + k * log(n) - BIC_mono","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Store the results:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(ΔAIC_v, ΔAIC)\npush!(ΔBIC_v, ΔBIC)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Unconstrained-qMT-fit-with-Graham's-model","page":"T₁ Mapping methods","title":"Unconstrained qMT fit with Graham's model","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"MT_model = Graham()\npush!(fit_name, \"unconstr_Graham\")\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"The following parameters are hard-coded with the exception of m0s, R1f, and R1s, which serve as an initialization for the global fit.","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"m0s = 0.25\nR1f = 1 / 1.84   # 1/s\nR1s = 1 / 0.34   # 1/s\nRx = 13.6        # 1/s\nR2f = 1 / 0.0769 # 1/s\nT2s = 12.5e-6    # s\nω0 = 0\nB1 = 1\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"We define a model for the global fit. It takes the global set of parameters p as an input and returns a vector of T₁ estimates that correspond to the T₁ mapping methods described by the vector T1_functions","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"function model(iseq, p)\n    m0s, R1f, R1s = p\n    T1 = similar(iseq, Float64)\n    Threads.@threads for i in eachindex(iseq)\n        T1[i] = T1_functions[iseq[i]](m0s, R1f, R2f, Rx, R1s, T2s)\n    end\n    return T1\nend","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Perform the fit and save the global set of parameters:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"fit_Graham = curve_fit(model, 1:length(T1_literature), T1_literature, [m0s, R1f, R1s], x_tol=1e-3)\npush!(fitted_param, (fit_Graham.param[1], fit_Graham.param[2], R2f, Rx, fit_Graham.param[3], T2s))\npush!(T1_simulated, model(1:length(T1_literature), fit_Graham.param))\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"For this model, the global set of parameters is:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"m0s_fitted = fit_Graham.param[1]","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"R1f_fitted = fit_Graham.param[2]","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"R2f","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Rx","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"R1s_fitted = fit_Graham.param[3]","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"T2s","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"where all but m0s, R1f, and R1s are fixed. The following plot visualizes the quality of the fit an replicates Fig. 1 in the manuscript:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"scatter!(p, T1_simulated[end], T1_literature, label=\"$(fit_name[end]) model\", markershape=marker_list, hover=seq_name)\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-2","page":"T₁ Mapping methods","title":"Akaike (AIC) and Bayesian (BIC) information criteria","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"The information criteria depend on the number of measurements n, the number of parameters k, and the squared sum of the residuals RSS:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"n = length(T1_literature)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"k = length(fit_mono.param)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"RSS = norm(fit_mono.resid)^2","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"With this information, we can calculate the AIC difference to the mono-exponential model:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"ΔAIC = n * log(RSS / n) + 2k - AIC_mono","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"and similarly for the BIC:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"ΔBIC = n * log(RSS / n) + k * log(n) - BIC_mono","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Store the results:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(ΔAIC_v, ΔAIC)\npush!(ΔBIC_v, ΔBIC)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Constrained-qMT-fit-with-the-generalized-Bloch-model","page":"T₁ Mapping methods","title":"Constrained qMT fit with the generalized Bloch model","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"MT_model = gBloch()\npush!(fit_name, \"constr_gBloch\")\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"The following parameters are hard-coded with the exception of m0s, and R1f, which serve as an initialization for the global fit.","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"m0s = 0.139\nR1f = 1 / 1.084  # 1/s\nR2f = 1 / 0.0769 # 1/s\nRx = 23          # 1/s\nR1s = 1          # 1/s\nT2s = 12.5e-6    # s\nω0 = 0\nB1 = 1\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"We define a model for the global fit. It takes the global set of parameters p as an input and returns a vector of T₁ estimates that correspond to the T₁ mapping methods described by the vector T1_functions","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"function model(iseq, p)\n    m0s, R1f = p\n    R1s = R1f\n    T1 = similar(iseq, Float64)\n    Threads.@threads for i in eachindex(iseq)\n        T1[i] = T1_functions[iseq[i]](m0s, R1f, R2f, Rx, R1s, T2s)\n    end\n    return T1\nend","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Perform the fit and save the global set of parameters:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"fit_constr = curve_fit(model, 1:length(T1_literature), T1_literature, [m0s, R1f], x_tol=1e-3)\npush!(fitted_param, (fit_constr.param[1], fit_constr.param[2], R2f, Rx, fit_constr.param[2], T2s))\npush!(T1_simulated, model(1:length(T1_literature), fit_constr.param))\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"For this model, the global set of parameters is:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"m0s_fitted = fit_constr.param[1]","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"R1f_fitted = fit_constr.param[2]","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"R2f","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Rx","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"R1s_fitted = fit_constr.param[2]","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"T2s","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"where all but m0s, R1f, and are fixed (R1s = R1f). The following plot visualizes the quality of the fit an replicates Fig. 1 in the manuscript:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"scatter!(p, T1_simulated[end], T1_literature, label=\"$(fit_name[end]) model\", markershape=marker_list, hover=seq_name)\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-3","page":"T₁ Mapping methods","title":"Akaike (AIC) and Bayesian (BIC) information criteria","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"The information criteria depend on the number of measurements n, the number of parameters k, and the squared sum of the residuals RSS:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"n = length(T1_literature)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"k = length(fit_mono.param)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"RSS = norm(fit_mono.resid)^2","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"With this information, we can calculate the AIC difference to the mono-exponential model:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"ΔAIC = n * log(RSS / n) + 2k - AIC_mono","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"and similarly for the BIC:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"ΔBIC = n * log(RSS / n) + k * log(n) - BIC_mono","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Store the results:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(ΔAIC_v, ΔAIC)\npush!(ΔBIC_v, ΔBIC)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Unconstrained qMT fit with the generalized Bloch model","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"MT_model = gBloch()\npush!(fit_name, \"unconstr_gBloch\")\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"The following parameters are hard-coded with the exception of m0s, R1f, and R1s, which serve as an initialization for the global fit.","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"m0s = 0.25\nR1f = 1 / 1.84   # 1/s\nR1s = 1 / 0.34   # 1/s\nRx = 13.6        # 1/s\nR2f = 1 / 0.0769 # 1/s\nT2s = 12.5e-6    # s\nω0 = 0\nB1 = 1\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"We define a model for the global fit. It takes the global set of parameters p as an input and returns a vector of T₁ estimates that correspond to the T₁ mapping methods described by the vector T1_functions","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"function model(iseq, p)\n    m0s, R1f, R1s = p\n    T1 = similar(iseq, Float64)\n    Threads.@threads for i in eachindex(iseq)\n        T1[i] = T1_functions[iseq[i]](m0s, R1f, R2f, Rx, R1s, T2s)\n    end\n    return T1\nend","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Perform the fit and save the global set of parameters:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"fit_uncon = curve_fit(model, 1:length(T1_literature), T1_literature, [m0s, R1f, R1s], x_tol=1e-3, show_trace=true)\npush!(fitted_param, (fit_uncon.param[1], fit_uncon.param[2], R2f, Rx, fit_uncon.param[3], T2s))\npush!(T1_simulated, model(1:length(T1_literature), fit_uncon.param))\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"For this model, the global set of parameters is:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"m0s_fitted = fit_uncon.param[1]","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"R1f_fitted = fit_uncon.param[2]","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"R2f","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Rx","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"R1s_fitted = fit_uncon.param[3]","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"T2s","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"where all but m0s, R1f, and R1s are fixed. The following plot visualizes the quality of the fit an replicates Fig. 1 in the manuscript:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"scatter!(p, T1_simulated[end], T1_literature, label=\"$(fit_name[end]) model\", markershape=marker_list, hover=seq_name)\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Akaike-(AIC)-and-Bayesian-(BIC)-information-criteria-4","page":"T₁ Mapping methods","title":"Akaike (AIC) and Bayesian (BIC) information criteria","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"The information criteria depend on the number of measurements n, the number of parameters k, and the squared sum of the residuals RSS:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"n = length(T1_literature)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"k = length(fit_mono.param)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"RSS = norm(fit_mono.resid)^2","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"With this information, we can calculate the AIC difference to the mono-exponential model:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"ΔAIC = n * log(RSS / n) + 2k - AIC_mono","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"and similarly for the BIC:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"ΔBIC = n * log(RSS / n) + k * log(n) - BIC_mono","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Store the results:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"push!(ΔAIC_v, ΔAIC)\npush!(ΔBIC_v, ΔBIC)\nnothing #hide","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Data-analysis","page":"T₁ Mapping methods","title":"Data analysis","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"The span of T₁ estimates in the literature is","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"extrema(T1_literature)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"and the coefficient of variation is","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"variation(T1_literature)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Median-absolute-deviation","page":"T₁ Mapping methods","title":"Median absolute deviation","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"In the paper, the median absolute deviation wrt. the mean value is used, as it is more robust to outliers compared to the mean absolute deviation or the standard deviation. Note, however, that the median absolute deviation of the mono-exponential fit is dominated by an outlier, artificially inflating the corresponding reduction.","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"A mono-exponential model explains the following fraction of the T₁ variability in the literature:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"1 - mad(fit_mono.resid;   center=mean(fit_mono.resid))    / mad(T1_literature; center=mean(T1_literature))","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Graham's spectral model without constraints on R₁ᶠ explains the following fraction of the T₁ variability in the literature:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"1 - mad(fit_Graham.resid; center=mean(fit_Graham.resid))  / mad(T1_literature; center=mean(T1_literature))","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"The generalized Bloch model constrained by R₁ˢ = R₁ᶠ explains the following fraction of the T₁ variability in the literature:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"1 - mad(fit_constr.resid; center=mean(fit_constr.resid))  / mad(T1_literature; center=mean(T1_literature))","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"The generalized Bloch model without constraints on R₁ᶠ explains the following fraction of the T₁ variability in the literature:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"1 - mad(fit_uncon.resid;  center=mean(fit_uncon.resid))   / mad(T1_literature; center=mean(T1_literature))","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Mean-absolute-deviation","page":"T₁ Mapping methods","title":"Mean absolute deviation","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"For comparison, the mean absolute deviation is analyzed: A mono-exponential model explains the following fraction of the T₁ variability in the literature:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"1 - mean(abs.(fit_mono.resid   .- mean(fit_mono.resid)))   / mean(abs.(T1_literature .- mean(T1_literature)))","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Graham's spectral model without constraints on R₁ᶠ explains the following fraction of the T₁ variability in the literature:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"1 - mean(abs.(fit_Graham.resid .- mean(fit_Graham.resid))) / mean(abs.(T1_literature .- mean(T1_literature)))","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"The generalized Bloch model constrained by R₁ˢ = R₁ᶠ explains the following fraction of the T₁ variability in the literature:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"1 - mean(abs.(fit_constr.resid .- mean(fit_constr.resid))) / mean(abs.(T1_literature .- mean(T1_literature)))","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"The generalized Bloch model without constraints on R₁ᶠ explains the following fraction of the T₁ variability in the literature:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"1 - mean(abs.(fit_uncon.resid  .- mean(fit_uncon.resid)))  / mean(abs.(T1_literature .- mean(T1_literature)))","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/#Standard-deviation","page":"T₁ Mapping methods","title":"Standard deviation","text":"","category":"section"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"For comparison, the standard deviation is analyzed: A mono-exponential model explains the following fraction of the T₁ variability in the literature:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"1 - std(fit_mono.resid)   / std(T1_literature)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"Graham's spectral model without constraints on R₁ᶠ explains the following fraction of the T₁ variability in the literature:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"1 - std(fit_Graham.resid) / std(T1_literature)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"The generalized Bloch model constrained by R₁ˢ = R₁ᶠ explains the following fraction of the T₁ variability in the literature:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"1 - std(fit_constr.resid) / std(T1_literature)","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"The generalized Bloch model without constraints on R₁ᶠ explains the following fraction of the T₁ variability in the literature:","category":"page"},{"location":"build_literate/Fit_qMT_to_literatureT1/","page":"T₁ Mapping methods","title":"T₁ Mapping methods","text":"1 - std(fit_uncon.resid)  / std(T1_literature)","category":"page"}]
}
